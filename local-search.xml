<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>面向对象</title>
    <link href="/2021/02/08/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2021/02/08/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h3 id="一面向对象的概念"><a class="markdownIt-Anchor" href="#一面向对象的概念"></a> 一，面向对象的概念</h3><blockquote><p>面向过程：C语言</p><p>面向对象：Java、C++、Python</p><p>面向过程和面向对象都是编程思想</p><p>面向过程和面向对象的区别：</p><ol><li>面向过程：重点放在程序的功能是如何执行的，身份是执行者</li><li>面向对象：重点放在程序的功能可以找谁来完成，身份是指挥者，面向对象的思想更加贴近实际生活</li></ol></blockquote><h3 id="二类和对象"><a class="markdownIt-Anchor" href="#二类和对象"></a> 二，类和对象</h3><blockquote><p>类：数据类型，一类事物的集合</p><ol><li><p>基本信息</p></li><li><p>行为</p></li></ol><p>对象：根据类创建出来一个实体（实例），这个对象具备了这个类中所有的基本信息和行为</p><ol><li>基本信息</li><li>行为</li></ol><p>例如：</p><p>类：</p><p>​护士类</p><pre><code>  1.基本信息：工号、姓名、部门  2.行为：打针，护理</code></pre><p>对象：</p><p>​护士对象：</p><ol><li>基本信息：89757、马磊、肛肠科</li><li>行为：具体的打针动作，如何进行护理</li></ol><p>代码中：基本信息 -&gt; 属性、行为 -&gt; 方法</p></blockquote><h3 id="三成员和局部"><a class="markdownIt-Anchor" href="#三成员和局部"></a> 三，成员和局部</h3><blockquote><p>成员：全局，定义在类中，方法外</p><ol><li>成员变量<ol><li>默认值：成员变量有默认值，默认值与数组的默认值相同；局部变量没有默认值</li><li>作用范围：成员变量的作用范围是整个类；局部变量的作用范围是定义它的方法</li><li>生命周期：局部变量在方法被调用后进入栈内存，方法执行完毕后，局部变量随着方法的出栈而被释放；成员变量随着对象的创建而出现，当对象释放后，成员变量才被释放。</li><li>当成员变量和局部变量重名时，会根据 “就近原则” 进行调用</li></ol></li><li>成员方法</li></ol><p>局部：定义在方法中</p><p>​1.局部变量</p></blockquote><h3 id="四类的定义和对象的创建"><a class="markdownIt-Anchor" href="#四类的定义和对象的创建"></a> 四，类的定义和对象的创建</h3><h4 id="41-类的定义"><a class="markdownIt-Anchor" href="#41-类的定义"></a> 4.1 类的定义</h4><blockquote><p>格式：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> 类名 </span>&#123;属性方法&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hero</span> </span>&#123;<span class="hljs-keyword">public</span> String name;<span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> hp;<span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> gender;<span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> level;<span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> exp;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">attack</span><span class="hljs-params">()</span></span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">back</span><span class="hljs-params">()</span></span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shopping</span><span class="hljs-params">()</span></span>&#123;&#125;&#125;</code></pre></blockquote><h4 id="42-对象的创建"><a class="markdownIt-Anchor" href="#42-对象的创建"></a> 4.2 对象的创建</h4><blockquote><p>格式：</p><pre><code class="hljs java">数据类型 对象名 = <span class="hljs-keyword">new</span> 数据类型();</code></pre><pre><code class="hljs java">Hero h = <span class="hljs-keyword">new</span> Hero();</code></pre></blockquote><h4 id="43-属性和方法的调用"><a class="markdownIt-Anchor" href="#43-属性和方法的调用"></a> 4.3 属性和方法的调用</h4><blockquote><p>格式：</p><pre><code class="hljs java">对象.方法名();赋值：对象.属性 = 值;获取：    数据类型 = 对象.属性;打印：    System.out.println(对象.属性);</code></pre><pre><code class="hljs java">h.attack();赋值：h.name = <span class="hljs-string">&quot;亚索&quot;</span>;获取：<span class="hljs-keyword">int</span> hp = h.hp;打印：System.out.println(h.exp);</code></pre></blockquote><h3 id="五将引用数据类型作为方法的参数和返回值"><a class="markdownIt-Anchor" href="#五将引用数据类型作为方法的参数和返回值"></a> 五，将引用数据类型作为方法的参数和返回值</h3><blockquote><p>如果传递的参数是引用数据类型，那么形参接收到的是实参的地址，这个形参指向这个实参在堆内存中的地址。</p><p>如果方法的返回值是引用数据类型，那么接收这个返回结果的变量接收到的就是返回的地址，这个变量指向返回值在内存中的地址。</p></blockquote><blockquote><p>注：</p><p>​在将引用数据类型的对象进行传递时，一定要避免空指针异常（NullPointerException）。</p><p>​什么时候会发生空指针异常：一个引用变量没有指向指定的存储空间或者这个引用变量的地址是 null 时，这个引用变量就是一个空对象，当使用空对象进行属性或者方法的调用时，就会发生空指针异常。</p></blockquote><h3 id="六构造函数方法-器"><a class="markdownIt-Anchor" href="#六构造函数方法-器"></a> 六，构造函数（方法、器）</h3><h4 id="61-构造函数的特点"><a class="markdownIt-Anchor" href="#61-构造函数的特点"></a> 6.1 构造函数的特点</h4><blockquote><ol><li>构造函数的函数名与类名一致</li><li>构造函数没有返回类型，连 void 都不能有</li><li>每次创建对象时都会执行构造函数</li><li>每一个类中都有一个默认的隐式的无参的构造函数</li><li>一旦构造函数重载了，那么原来的默认构造函数就不存在了，如果还要使用无参构造函数来创建对象，就必须再重新写出这个无参构造函数</li></ol></blockquote><h4 id="62-构造函数的作用"><a class="markdownIt-Anchor" href="#62-构造函数的作用"></a> 6.2 构造函数的作用</h4><blockquote><ol><li>创建对象</li><li>创建对象时对属性进行初始化</li></ol></blockquote><h4 id="63-构造函数的重载"><a class="markdownIt-Anchor" href="#63-构造函数的重载"></a> 6.3 构造函数的重载</h4><blockquote><p>定义若干个构造函数，参数列表不同</p><p>作用：创建对象的同时对属性进行初始化</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Employee</span><span class="hljs-params">(String a, <span class="hljs-keyword">int</span> b, String c)</span></span>&#123;name = a;level = b;report = c;&#125;</code></pre></blockquote><blockquote><pre><code class="hljs java">Employee e = <span class="hljs-keyword">new</span> Employee(<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-number">4</span>,<span class="hljs-string">&quot;良好&quot;</span> );</code></pre></blockquote><h4 id="64-this-关键字"><a class="markdownIt-Anchor" href="#64-this-关键字"></a> 6.4 this 关键字</h4><blockquote><p>在创建对象后，可以通过 this 关键字来获取该对象的地址（可以通过 this 来表示当前创建出来的对象），所以我们可以使用 this 来明确变量是当前类型中对象的属性。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Employee</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> level, String report)</span></span>&#123;System.out.println(<span class="hljs-string">&quot;this的地址：&quot;</span>+<span class="hljs-keyword">this</span>);<span class="hljs-keyword">this</span>.name = name;<span class="hljs-keyword">this</span>.level = level;<span class="hljs-keyword">this</span>.report = report;&#125;</code></pre></blockquote><blockquote><p>this 的作用：</p><ol><li><p>调用属性、调用方法 （this可以省略）</p></li><li><p>调用本类的其他构造函数</p><p>作用：当多个构造函数中出现了重复的初始化语句时，可以使用 this 调用其他构造函数来简化代码完善对象属性的赋值</p><p>注：构造方法的调用只能出现在其他构造函数的第一行</p></li></ol></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>1.8新特性</title>
    <link href="/2019/02/22/1-8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <url>/2019/02/22/1-8%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h3 id="一函数式编程思想"><a class="markdownIt-Anchor" href="#一函数式编程思想"></a> 一，函数式编程思想</h3><h4 id="11-概念"><a class="markdownIt-Anchor" href="#11-概念"></a> 1.1 概念</h4><blockquote><p>在数学中，函数就是一套计算方案。它重点放在 “ 拿什么东西就能做什么事情 ”。</p><p>对于面向对象的编程思想而言，我们必须明确是哪一个对象来做这件事情的，</p><p>而函数式编程思想的重点是 “ 做什么，不是以什么形式来做 。”</p></blockquote><h4 id="12-函数式编程思想和面向对象思想比较案例"><a class="markdownIt-Anchor" href="#12-函数式编程思想和面向对象思想比较案例"></a> 1.2 函数式编程思想和面向对象思想比较案例</h4><blockquote><pre><code class="hljs java"><span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable()&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= <span class="hljs-number">100</span>; i++)&#123;            System.out.println(Thread.currentThread().getName() +<span class="hljs-string">&quot;---&quot;</span>+i);        &#125;    &#125;&#125;).start();<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= <span class="hljs-number">100</span>; i++)&#123;        System.out.println(Thread.currentThread().getName() +<span class="hljs-string">&quot;---&quot;</span>+i);    &#125;&#125;).start();</code></pre><p>如果要使用实现 Runnable 接口的方式开启线程，我们必须创建出 Runnable 的实现类对象，并重写 run() 方法明确线程中要执行的任务。我们的重点是开启线程，让线程执行指定的任务，而不是创建 Runnable 的实现类对象也不是去重写 run() 方法。实际上，只有 run() 方法中的方法体才有重点。</p></blockquote><h4 id="13-lambda表达式的语法"><a class="markdownIt-Anchor" href="#13-lambda表达式的语法"></a> 1.3 Lambda表达式的语法</h4><blockquote><p>组成：</p><ol><li>参数列表</li><li>箭头</li><li>代码块</li></ol><p>格式：</p><pre><code class="hljs java">（参数列表）-&gt; &#123; 代码块 &#125;</code></pre><p>格式说明：</p><ol><li>()：表示接口中抽象方法的参数列表；方法没有参数的话就留空，有的话就跟着接口中的这个方法的参数列表来写。</li><li>-&gt;：传递的意思，把参数传递给方法体</li><li>{}：重写接口抽象方法的方法体</li></ol><p>Lambda表达式中可以省略的内容：</p><ol><li>参数列表中的类型</li><li>如果参数只有一个，那么连 &quot; () &quot;也能省略，此时 &quot; () &quot; 省略情况下，类型一定不能写</li><li>如果 &quot; {} &quot; 中只有一行代码，<ol><li>重写的方法没有返回值：可以省略 &quot; {} &quot; ，此时该语句的分号必须省略</li><li>重写的方法有返回值：可以省略 &quot; {} &quot;，此时 &quot; reuturn &quot; 和 分号 必须省略</li></ol></li></ol><p>Lambda 的使用前提：</p><ol><li>使用 Lambda 表达式必须要有接口，接口中有且只能有一个抽象方法，默认的方法、静态的方法、私有方法也可以包含。</li><li>方法的参数必须是函数式接口，才能使用 Lambda  作为该接口的实例</li></ol><p>函数式接口：有且仅有一个抽象方法的接口，可以通过 @FunctionalInterface 注解来校验该接口是否的函数式接口</p></blockquote><h4 id="14-常见的函数式接口"><a class="markdownIt-Anchor" href="#14-常见的函数式接口"></a> 1.4 常见的函数式接口</h4><h5 id="141-supplier"><a class="markdownIt-Anchor" href="#141-supplier"></a> 1.4.1 Supplier</h5><blockquote><p>该接口中有一个无参的抽象方法：T get()</p><p>它用来获取一个泛型参数指定的数据类型的对象</p></blockquote><h5 id="142-predicate"><a class="markdownIt-Anchor" href="#142-predicate"></a> 1.4.2 Predicate</h5><blockquote><p>该接口中有一个无参的抽象方法：boolean test(T t)，两个默认方法：and() 、or()</p><p>它用来判断是否满足条件</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>反射</title>
    <link href="/2019/02/19/%E5%8F%8D%E5%B0%84/"/>
    <url>/2019/02/19/%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h3 id="一类的加载"><a class="markdownIt-Anchor" href="#一类的加载"></a> 一，类的加载</h3><blockquote><p>当程序要使用某一个类时，如果该类还没有进入到内存，那么系统会通过加载，连接，初始化</p><ol><li>加载：将类的class文件读取到内存中，并为它创建一个 Class 对象，任何类被加载后都会创建唯一的一个 Class 对象</li><li>连接：校验类的内部结构是否正确；为静态成员分配内存。</li><li>初始化：创建对象</li></ol></blockquote><h3 id="二类加载器"><a class="markdownIt-Anchor" href="#二类加载器"></a> 二，类加载器</h3><blockquote><p>类加载器负责将 .class 文件加载到内存中，并为它生成对应的 Class 对象</p></blockquote><h3 id="三反射"><a class="markdownIt-Anchor" href="#三反射"></a> 三，反射</h3><blockquote><p>概念：Java的反射机制是指，程序在运行状态下，对于任何一个类，都能知道这个类中的所有属性和方法；对于任何一个对象，都能调用它的任意一个属性和方法。这种动态获取信息以及动态调用属性和方法的功能就称为反射。</p><p>注：要剖析一个类的内部结构，必须先得到这个类的字节码文件对象</p></blockquote><h3 id="四字节码文件对象的获取"><a class="markdownIt-Anchor" href="#四字节码文件对象的获取"></a> 四，字节码文件对象的获取</h3><blockquote><ol><li>通过对象获取</li><li>通过类名获取</li><li>通过 Class 类中的静态方法获取</li></ol><pre><code class="hljs java"><span class="hljs-comment">// 1.</span>Person p = <span class="hljs-keyword">new</span> Person();Class c1 = p.getClass();System.out.println(c1);System.out.println(<span class="hljs-string">&quot;-------------------------------&quot;</span>);<span class="hljs-comment">// 2.</span>Class c2 = Person.class;System.out.println(c2);System.out.println(<span class="hljs-string">&quot;-------------------------------&quot;</span>);<span class="hljs-comment">// 3.</span><span class="hljs-comment">// 类名必须写成全限定类名（全类名）</span>Class c3 = Class.forName(<span class="hljs-string">&quot;com.qf.test1.Person&quot;</span>);System.out.println(c3);</code></pre></blockquote><h3 id="五通过反射获取构造方法并创建对象"><a class="markdownIt-Anchor" href="#五通过反射获取构造方法并创建对象"></a> 五，通过反射获取构造方法，并创建对象</h3><blockquote><p>通过 Class 对象可以调用以下方法获取构造器对象：</p><ol><li>getConstructors()：返回非私有的构造函数对象组成的数组</li><li>getDeclaredConstructors()：返回所有构造函数对象组成的数组（包括私有的）</li><li>getConstructor(Class…c)：获取非私有的指定参数的构造函数对象</li><li>getDeclaredConstructor(Class…c)：获取指定参数的构造函数对象（包括私有的）</li></ol><p>通过构造器对象可以创建对象：</p><ol><li>newInstance(Object… o)：根据指定构造器的参数传入实参创建该类对象</li><li>setAccessible(boolean b)：暴力反射，取消私有化，不建议使用，因为破坏了封装性</li></ol><p>注：Class 中也有 newInstance() 方法来创建该类对象，但是只能通过默认的构造函数来创建对象</p></blockquote><h3 id="六通过反射获取成员变量并赋值"><a class="markdownIt-Anchor" href="#六通过反射获取成员变量并赋值"></a> 六，通过反射获取成员变量，并赋值</h3><blockquote><p>通过 Class 对象可以调用以下方法获取属性对象：</p><ol><li>getFields()：返回非私有的属性对象组成的数组</li><li>getDeclaredFields()：返回所有属性对象组成的数组（包括私有的）</li><li>getField(String name)：通过属性名获取非私有的指定参数的属性对象</li><li>getDeclaredField(String name)：通过属性名获取指定参数的属性对象（包括私有的）</li></ol><p>通过属性对象可以为指定对象的该属性赋值：</p><ol><li>set(Object obj，Object value)</li><li>setAccessible(boolean b)</li></ol></blockquote><h3 id="七通过反射获取成员方法并调用"><a class="markdownIt-Anchor" href="#七通过反射获取成员方法并调用"></a> 七，通过反射获取成员方法，并调用</h3><blockquote><p>​通过 Class 对象可以调用以下方法获取方法对象：</p><ol><li>getMethods()：返回非私有的方法对象组成的数组（包括继承下来的）</li><li>getDeclaredMethods()：返回所有方法对象组成的数组（包括私有的，不包括继承下来的）</li><li>getMethod(String name, Class…c)：通过方法名和参数列表获取非私有的指定参数的方法对象</li><li>getDeclaredMethod(String name, Class…c)：通过方法名和参数列表获取指定参数的方法对象（包括私有的）</li></ol><p>通过方法对象调用 invoke() 来执行该功能：</p><ol><li>invoke(Object obj, Object…o)</li><li>setAccessible(boolean b)</li></ol></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>网络编程</title>
    <link href="/2019/02/17/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <url>/2019/02/17/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="一网络编程的三要素"><a class="markdownIt-Anchor" href="#一网络编程的三要素"></a> 一，网络编程的三要素</h3><h4 id="11-ip地址"><a class="markdownIt-Anchor" href="#11-ip地址"></a> 1.1 IP地址</h4><blockquote><p>IP（Internet Protocol Address）地址是物理地址，用于标识网络中的计算机设备</p><p>查看本机IP地址：cmd-&gt;ipconfig</p><p>查看网络是否连通：cmd-&gt;ping 域名/IP地址</p><p>IPv4：是一个32的二进制数，表示形式：<a href="http://xxx.xxx.xxx.xxx">xxx.xxx.xxx.xxx</a>，能够表示42亿多个IP地址</p><p>IPv6：表示形式：xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx，每16个字节为一组，分成8组，每一个x可以表示0~f</p><p>注：本机的IP地址：localhost、127.0.0.1</p></blockquote><h4 id="12-端口号"><a class="markdownIt-Anchor" href="#12-端口号"></a> 1.2 端口号</h4><blockquote><p>端口号（port）是逻辑地址，用于标识设备中的应用的</p><p>端口号的范围：0<sub>65535，特殊的一般如0</sub>1023之间的端口号用于一些知名（系统）的网络服务和应用</p><p>表示形式：ip 地址 : 端口号</p></blockquote><h4 id="13-传输协议"><a class="markdownIt-Anchor" href="#13-传输协议"></a> 1.3 传输协议</h4><blockquote><p>数据在网络中进行传输时需要遵循的规则</p><p>在 <a href="http://java.net">java.net</a> 包中定义了使用 UDP、TCP 协议完成数据传输的类</p></blockquote><blockquote><p>UDP：User Datagram Protocol，用户数据报协议</p><p>​特点：</p><ol><li><p>无需建立连接，发送端不会去确认接收端是否存在</p></li><li><p>速度快</p></li><li><p>不可靠</p></li><li><p>应用领域：在线视频</p></li><li><p>代码中：传输的数据与目标地址要封装在同一个数据包对象中</p></li></ol><p>核心类：</p><ol><li>DatagramSocket：封装了数据的收发功能</li><li>DatagramPacket：数据包，封装要传输的数据，如果是发送方还要封装发送的目标地址</li></ol></blockquote><blockquote><p>TCP：Transmission Control Protocol，传输控制协议</p><p>​特点：</p><ol><li>在底层通过三次握手来建立连接，保证数据的安全<ol><li>第一次，客户端向服务器发出连接请求，等待服务器的确认</li><li>第二次，服务器向客户端发送一个响应，通知客户端收到了连接的请求</li><li>第三次，客户端再次向服务器发送确认信息，来确认连接</li></ol></li><li>速度慢</li><li>可靠的</li><li>应用领域：下载</li></ol><p>核心类：</p><ol><li>ServerSocket：表示服务端</li><li>Socket：表示客户端</li></ol></blockquote><h3 id="二inetaddress"><a class="markdownIt-Anchor" href="#二inetaddress"></a> 二，InetAddress</h3><blockquote><p>概念：InetAddress 类是 <a href="http://java.net">java.net</a> 包下的一个用于获取域名和IP地址的类</p><p>方法：该类的方法都是静态方法</p><ol><li>getByName(String host)</li><li>getLocalHost()</li><li>getAllByName(String host)</li></ol></blockquote><h3 id="三udp的使用"><a class="markdownIt-Anchor" href="#三udp的使用"></a> 三，UDP的使用</h3><h4 id="31-一个端接收一个端发送"><a class="markdownIt-Anchor" href="#31-一个端接收一个端发送"></a> 3.1 一个端接收一个端发送</h4><blockquote><pre><code class="hljs java"><span class="hljs-comment">// 发送端</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UDPClient1</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<span class="hljs-comment">// 当前这个类只用于发送，不接收数据，因此不需要明确自己的端口号</span>DatagramSocket ds = <span class="hljs-keyword">new</span> DatagramSocket();String msg = <span class="hljs-string">&quot;闭嘴&quot;</span>;<span class="hljs-keyword">byte</span>[] b = msg.getBytes();        /        * 参数：        * <span class="hljs-number">1.</span>要发送的数据，类型的字节数组        * <span class="hljs-number">2.</span>发送数据的大小        * <span class="hljs-number">3.</span>InetAddress对象，该对象中要封装目标的IP地址        * <span class="hljs-number">4.</span>端口号，端口号的值要和接收端的端口号一致        */DatagramPacket dp = <span class="hljs-keyword">new</span> DatagramPacket(b, b.length, InetAddress.getByName(<span class="hljs-string">&quot;10.11.53.114&quot;</span>), <span class="hljs-number">1234</span>);        <span class="hljs-comment">// 发送功能，因为你在发送，所以你的DatagramPacket中要有目标的IP地址及端口号</span>ds.send(dp);        <span class="hljs-comment">// 释放资源</span>ds.close();&#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">// 接收端</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UDPClient2</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<span class="hljs-comment">// 当前这个类用于接收数据，要设置自己的端口号，才能让发送者在发送时能明确目标地址</span>DatagramSocket ds = <span class="hljs-keyword">new</span> DatagramSocket(<span class="hljs-number">1234</span>);<span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];        <span class="hljs-comment">// 作为接收端中的byte数组是作为缓冲使用的</span>DatagramPacket dp = <span class="hljs-keyword">new</span> DatagramPacket(b, b.length);        <span class="hljs-comment">// 接收功能，当程序运行到这句话时会处于阻塞状态，等待发送端的发送动作，当发送端执行了发送功能，数据包中的byte数组会接收到数据</span>ds.receive(dp);        <span class="hljs-comment">// 获取byte数组中的数据</span><span class="hljs-keyword">byte</span>[] msg = dp.getData();        <span class="hljs-comment">// 获取接收到的有效数据大小</span><span class="hljs-keyword">int</span> len = dp.getLength();System.out.println(<span class="hljs-keyword">new</span> String(msg,<span class="hljs-number">0</span>,len));&#125;&#125;</code></pre></blockquote><h4 id="32-同时收发"><a class="markdownIt-Anchor" href="#32-同时收发"></a> 3.2 同时收发</h4><blockquote><pre><code class="hljs java">&gt;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UDPCilent1</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-comment">// 收</span><span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable()&#123;           <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<span class="hljs-keyword">try</span> &#123;DatagramSocket ds = <span class="hljs-keyword">new</span> DatagramSocket(<span class="hljs-number">7777</span>);<span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];DatagramPacket dp = <span class="hljs-keyword">new</span> DatagramPacket(b, b.length);ds.receive(dp);<span class="hljs-keyword">byte</span>[] msg = dp.getData();<span class="hljs-keyword">int</span> len = dp.getLength();System.out.println(<span class="hljs-keyword">new</span> String(msg,<span class="hljs-number">0</span>,len));&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;e.printStackTrace();&#125;&#125;&#125;       &#125;).start();<span class="hljs-comment">// 发</span><span class="hljs-keyword">new</span> Thread()&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<span class="hljs-keyword">try</span> &#123;DatagramSocket ds = <span class="hljs-keyword">new</span> DatagramSocket();String msg = <span class="hljs-keyword">new</span> Scanner(System.in).next();<span class="hljs-keyword">byte</span> b[] = msg.getBytes();DatagramPacket dp = <span class="hljs-keyword">new</span> DatagramPacket(b, b.length, InetAddress.getByName(<span class="hljs-string">&quot;10.11.53.114&quot;</span>),<span class="hljs-number">8888</span>);ds.send(dp);&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;&#125;&#125;&#125;&#125;.start();&#125;&gt;&#125;</code></pre></blockquote><h3 id="四tcp的使用"><a class="markdownIt-Anchor" href="#四tcp的使用"></a> 四，TCP的使用</h3><h4 id="41-服务端收客户端发"><a class="markdownIt-Anchor" href="#41-服务端收客户端发"></a> 4.1 服务端收，客户端发</h4><blockquote><pre><code class="hljs java"><span class="hljs-comment">// 服务端（收）</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TCPServer</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;        <span class="hljs-comment">// 创建服务器对象，并设置当前服务器的端口号，才能让发送者在发送时能明确目标地址</span>ServerSocket ss = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">1234</span>);<span class="hljs-comment">// 使当前服务器处于阻塞状态，等待其他客户端的连入，返回连入的客户端对象</span>Socket s = ss.accept();<span class="hljs-comment">// 根据连入的客户端对象s获取字节输入流，该输入流用于接收连入的客户端所发来的数据</span>InputStream is = s.getInputStream();<span class="hljs-keyword">byte</span> b[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<span class="hljs-keyword">int</span> len = is.read(b);System.out.println(<span class="hljs-string">&quot;接收到了：&quot;</span>+<span class="hljs-keyword">new</span> String(b,<span class="hljs-number">0</span>,len));is.close();s.close();ss.close();&#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">// 客户端（发）</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TCPClient</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;        <span class="hljs-comment">// 创建客户端对象，并明确所要连入服务器的ip地址和端口号，如果要连入的服务器已经执行到了accept()方法，那么此时，当前这个客户端对象就连入了指定的服务器，服务器也接收到了连入的客户端对象</span>Socket s = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">&quot;10.11.53.114&quot;</span>, <span class="hljs-number">1234</span>);       <span class="hljs-comment">// 获取客户端的输出流对象，该输出流用于向已经连入的服务器进行数据的发送</span>OutputStream os = s.getOutputStream();os.write(<span class="hljs-string">&quot;你好&quot;</span>.getBytes());os.close();s.close();&#125;&#125;</code></pre></blockquote><h4 id="42-客户端服务端同时收发"><a class="markdownIt-Anchor" href="#42-客户端服务端同时收发"></a> 4.2 客户端服务端同时收发</h4><blockquote><pre><code class="hljs java"><span class="hljs-comment">// 客户端</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TCPClient</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;Socket s = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">&quot;10.11.53.114&quot;</span>, <span class="hljs-number">6666</span>);<span class="hljs-comment">// 收</span><span class="hljs-keyword">new</span> Thread()&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<span class="hljs-keyword">try</span> &#123;InputStream is = s.getInputStream();<span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<span class="hljs-keyword">int</span> len = is.read(b);System.out.println(<span class="hljs-keyword">new</span> String(b,<span class="hljs-number">0</span>,len));&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;&#125;&#125;&#125;&#125;.start();        <span class="hljs-comment">// 发</span><span class="hljs-keyword">new</span> Thread()&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<span class="hljs-keyword">try</span> &#123;OutputStream os = s.getOutputStream();os.write(<span class="hljs-keyword">new</span> Scanner(System.in).next().getBytes());&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;&#125;&#125;&#125;&#125;.start();&#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">// 服务端</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TCPServer</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;ServerSocket ss = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">6666</span>); Socket s = ss.accept();<span class="hljs-comment">// 收</span><span class="hljs-keyword">new</span> Thread()&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<span class="hljs-keyword">try</span> &#123;InputStream is = s.getInputStream();<span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<span class="hljs-keyword">int</span> len = is.read(b);System.out.println(<span class="hljs-keyword">new</span> String(b,<span class="hljs-number">0</span>,len));&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;&#125;&#125;&#125;&#125;.start();<span class="hljs-comment">// 发</span><span class="hljs-keyword">new</span> Thread()&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<span class="hljs-keyword">try</span> &#123;OutputStream os = s.getOutputStream();os.write(<span class="hljs-keyword">new</span> Scanner(System.in).next().getBytes());&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;&#125;&#125;&#125;&#125;.start();&#125;&#125;</code></pre></blockquote><h4 id="43-聊天室"><a class="markdownIt-Anchor" href="#43-聊天室"></a> 4.3 聊天室</h4><blockquote><pre><code class="hljs java"><span class="hljs-comment">// 服务端</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TCPServer</span> </span>&#123;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Socket&gt; sockets = <span class="hljs-keyword">null</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span>  <span class="hljs-keyword">throws</span> Exception</span>&#123;ServerSocket ss = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">6969</span>);sockets = <span class="hljs-keyword">new</span> ArrayList&lt;Socket&gt;();<span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<span class="hljs-keyword">try</span> &#123;Socket s = ss.accept();sendAll(s);sockets.add(s);<span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<span class="hljs-keyword">try</span> &#123;InputStream is = s.getInputStream();<span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<span class="hljs-keyword">int</span> len = is.read(b);String msg = <span class="hljs-keyword">new</span> String(b,<span class="hljs-number">0</span>,len);sendAll(s,msg);&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;&#125;&#125;&#125;&#125;).start();&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;&#125;&#125;&#125;&#125;).start();&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendAll</span><span class="hljs-params">(Socket s, String str)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;String ip = s.getInetAddress().getHostAddress();String time = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;HH:ss:mm&quot;</span>).format(<span class="hljs-keyword">new</span> Date());String msg = ip+<span class="hljs-string">&quot;在&quot;</span>+time+<span class="hljs-string">&quot;发送了：&quot;</span>+str;System.out.println(msg);BufferedWriter bw = <span class="hljs-keyword">new</span> BufferedWriter(<span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">&quot;C:\\Users\\qianfeng\\Desktop\\log.txt&quot;</span>,<span class="hljs-keyword">true</span>));bw.write(msg);bw.newLine();bw.flush();<span class="hljs-keyword">for</span> (Socket socket : sockets) &#123;OutputStream os = socket.getOutputStream();os.write(msg.getBytes());&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendAll</span><span class="hljs-params">(Socket s)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;String ip = s.getInetAddress().getHostAddress();String time = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;HH:ss:mm&quot;</span>).format(<span class="hljs-keyword">new</span> Date());String msg = ip+<span class="hljs-string">&quot;在&quot;</span>+time+<span class="hljs-string">&quot;加入了聊天室&quot;</span>;System.out.println(msg);<span class="hljs-keyword">for</span> (Socket socket : sockets) &#123;OutputStream os = socket.getOutputStream();os.write(msg.getBytes());&#125;&#125;&#125;</code></pre></blockquote><h4 id="44-文件上传"><a class="markdownIt-Anchor" href="#44-文件上传"></a> 4.4 文件上传</h4><blockquote><pre><code class="hljs java"><span class="hljs-comment">// 客户端</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TCPClient</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<span class="hljs-comment">/*</span><span class="hljs-comment"> * 将本地文件上传至服务器</span><span class="hljs-comment"> * 1.读取本地文件</span><span class="hljs-comment"> * 2.上传到服务器</span><span class="hljs-comment"> * 3.读取服务器的回写数据</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * 准备工作</span><span class="hljs-comment"> * 1.数据源：要上传的文件 E:\test</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * 步骤：</span><span class="hljs-comment"> * 1.创建本地的FileInputStream，来明确要读取的本地文件</span><span class="hljs-comment"> * 2.创建Socket对象，绑定要连入的服务器的ip和端口号</span><span class="hljs-comment"> * 3.使用Socket的getOutputStream获取网络输出流对象</span><span class="hljs-comment"> * 4.使用本地的FileInputStream的read()方法读取本地文件</span><span class="hljs-comment"> * 5.使用Socket的网络输出流的write()方法将读取到的流对象写到服务器</span><span class="hljs-comment"> * 6.使用Socket的getInputStream获取网络输入流对象</span><span class="hljs-comment"> * 7.使用Socket的网络输入流的read()方法读取服务器回写的数据</span><span class="hljs-comment"> * 8.释放资源</span><span class="hljs-comment"> */</span>FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;E:\\test\\黑寡妇.png&quot;</span>);Socket s = <span class="hljs-keyword">new</span> Socket(InetAddress.getByName(<span class="hljs-string">&quot;10.11.53.114&quot;</span>), <span class="hljs-number">5678</span>);OutputStream os = s.getOutputStream();<span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;<span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<span class="hljs-keyword">while</span>((len = fis.read(b)) != -<span class="hljs-number">1</span>)&#123;os.write(b, <span class="hljs-number">0</span>, len);&#125;<span class="hljs-comment">/*</span><span class="hljs-comment"> * bug：图片已经成功上传到服务器了，但是客户端没有接收到回写的数据</span><span class="hljs-comment"> * 原因：不是客户端没有接收到回写的数据，而是服务器没有执行到回写功能</span><span class="hljs-comment"> * 我们需要在图片完毕后，告知服务器，告知的方式是向服务器发送一个结束的标记</span><span class="hljs-comment"> */</span>s.shutdownOutput();InputStream is = s.getInputStream();<span class="hljs-keyword">while</span>((len = is.read(b)) != -<span class="hljs-number">1</span>)&#123;System.out.println(<span class="hljs-keyword">new</span> String(b,<span class="hljs-number">0</span>,len));&#125;s.close();fis.close();&#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">// 服务端</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TCPServer</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<span class="hljs-comment">/*</span><span class="hljs-comment"> * 将本地文件上传至服务器</span><span class="hljs-comment"> * 1.读取客户端上传的文件</span><span class="hljs-comment"> * 2.将文件保存到本地服务器</span><span class="hljs-comment"> * 3.回写数据</span><span class="hljs-comment"> * </span><span class="hljs-comment">  * 准备工作</span><span class="hljs-comment"> * 2.明确目标地址: E:\资料</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * 步骤：</span><span class="hljs-comment"> * 1.创建ServerSocket对象，指定端口号</span><span class="hljs-comment"> * 2.通过ServerSocket的accept()方法，获取客户端对象</span><span class="hljs-comment"> * 3.使用客户端对象的getInputStream获取网络输入流对象</span><span class="hljs-comment"> * 4.判断“同学们的好图”这个目录是否存在，不存在，则创建</span><span class="hljs-comment"> * 5.创建本地的FileOutputStream，明确读取到的文件往哪里存</span><span class="hljs-comment"> * 6.使用客户端的网络输入流对象的read()方法，读取文件</span><span class="hljs-comment"> * 7.使用本地输出流对象的write()方法写文件</span><span class="hljs-comment"> * 8.使用客户端对象的getOutputStream获取网络输出流对象</span><span class="hljs-comment"> * 9.使用网络输出流对象的writer()方法回写“上传成功”</span><span class="hljs-comment"> * 10.释放资源</span><span class="hljs-comment"> * </span><span class="hljs-comment"> */</span>ServerSocket ss = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">5678</span>);<span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;Socket s = ss.accept();<span class="hljs-keyword">new</span> Thread()&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">try</span> &#123;InputStream is = s.getInputStream();File f = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;E:\\资料\\同学们的好图&quot;</span>);<span class="hljs-keyword">if</span>(!f.exists())&#123;f.mkdirs();&#125;<span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;<span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];String filename = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyyMMddHHssmm&quot;</span>).format(<span class="hljs-keyword">new</span> Date())+<span class="hljs-string">&quot;&quot;</span>+<span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">1000000000</span>)+<span class="hljs-string">&quot;.jpg&quot;</span>;FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-keyword">new</span> File(f,filename));<span class="hljs-keyword">while</span>((len = is.read(b)) != -<span class="hljs-number">1</span>)&#123;fos.write(b, <span class="hljs-number">0</span>, len);&#125;OutputStream os = s.getOutputStream();os.write(<span class="hljs-string">&quot;上传成功！！！&quot;</span>.getBytes());fos.close();s.close();&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;&#125;&#125;&#125;.start();&#125;&#125;&#125;</code></pre></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>IO流</title>
    <link href="/2019/02/16/IO%E6%B5%81/"/>
    <url>/2019/02/16/IO%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h3 id="一io流的概述"><a class="markdownIt-Anchor" href="#一io流的概述"></a> 一，IO流的概述</h3><h4 id="11-什么是io流"><a class="markdownIt-Anchor" href="#11-什么是io流"></a> 1.1 什么是IO流</h4><blockquote><p>我们把数据的传输，看成是一种数据的流动，按照指定的流向进行输出的输入和输出。以内存为基准。</p></blockquote><h4 id="12-io流的分类"><a class="markdownIt-Anchor" href="#12-io流的分类"></a> 1.2 IO流的分类</h4><blockquote><p>根据数据的流向划分：输入流 和 输出流</p><p>​输入流：把数据从其他设备上读取到内存中</p><p>​输出流：把数据从内存中写到其他设备上</p><p>根据数据的类型划分：字节流 和 字符流</p><p>​字节流：以字节为单位，任何文件都可以使用字节流进行读写</p><p>​字符流：以字符为单位，一般只能对文本进行读写</p></blockquote><h4 id="13-io流的顶层父类"><a class="markdownIt-Anchor" href="#13-io流的顶层父类"></a> 1.3 IO流的顶层父类</h4><blockquote><p>字节输入流：InputStream</p><p>字节输出流：OutputStream</p><p>字符输入流：Reader</p><p>字符输出流：Writer</p><p>注：</p><ol><li>它们及其子类们都在 <a href="http://java.io">java.io</a> 包中</li><li>它们都是 抽象类</li></ol></blockquote><h3 id="二fileoutputstream-文件字节输出流"><a class="markdownIt-Anchor" href="#二fileoutputstream-文件字节输出流"></a> 二，FileOutputStream 文件字节输出流</h3><h4 id="21-概述"><a class="markdownIt-Anchor" href="#21-概述"></a> 2.1 概述</h4><blockquote><p>概述：该类是 OutputStream 的一个专门针对文件进行写出的流，它定义了一系列与写出相关的方法。</p></blockquote><h4 id="22-构造函数"><a class="markdownIt-Anchor" href="#22-构造函数"></a> 2.2 构造函数</h4><blockquote><ol><li>new FileOutputStream(File f)：根据指定文件对象所指向的文件路径创建文件字节输出流对象</li><li>new FileOutputStream(String name)：根据指定文件路径创建文件字节输出流对象</li><li>new FileOutputStream(File f，boolean b)：功能同上，第二个参数值为 true 时，表示该文件可以续写</li><li>new FileOutputStream(String name，boolean b)：功能同上，第二个参数值为 true 时，表示该文件可以续写</li></ol></blockquote><h4 id="23-常用方法"><a class="markdownIt-Anchor" href="#23-常用方法"></a> 2.3 常用方法</h4><blockquote><ol><li>close()：释放资源，如果执行了 close() 方法，那么就不能在写入了</li><li>flush()：刷新缓冲区</li><li>write(int ch)：根据十进制数写入对应的字符</li><li>writer(byte[] b)：写入指定的字节数组，如果要写入字符串，可以通过，字符串的 getBytes() 方法获取对应的字节数组</li><li>writer(byte[] b，int index ，int lenth)：从字节数组中的指定位置获取指定数量的元素写入到文件中</li></ol><p>注：</p><ol><li>如果想要续写，需要使用带有 boolean 参数的构造函数来创建对象，并且布尔值必须是 true</li><li>关于输出换行：<ol><li>windows：\r\n</li><li>unix：\n</li><li>mac：\r</li></ol></li><li>流用完后一定要关闭</li></ol></blockquote><h3 id="三fileinputstream-文件字节输入流"><a class="markdownIt-Anchor" href="#三fileinputstream-文件字节输入流"></a> 三，FileInputStream 文件字节输入流</h3><h4 id="31概述"><a class="markdownIt-Anchor" href="#31概述"></a> 3.1概述</h4><blockquote><p>概述：该类是 InputStream 的一个专门针对文件进行读取的流，它定义了一系列与读取相关的方法。</p></blockquote><h4 id="32-构造函数"><a class="markdownIt-Anchor" href="#32-构造函数"></a> 3.2 构造函数</h4><blockquote><ol><li>new FileInputStream(File f)：根据指定文件对象所指向的文件路径创建文件字节输入流对象</li><li>new FileInputStream(String name)：根据指定文件路径创建文件字节输入流对象</li></ol></blockquote><h4 id="33-常用方法"><a class="markdownIt-Anchor" href="#33-常用方法"></a> 3.3 常用方法</h4><blockquote><ol><li>read()：读取单个字符所对应的十进制数，返回 -1 表示读完了</li></ol><pre><code class="hljs java">FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;E:\\资料\\demo\\t1.txt&quot;</span>);<span class="hljs-keyword">int</span> ch = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>((ch = fis.read()) != -<span class="hljs-number">1</span>)&#123;    System.out.println((<span class="hljs-keyword">char</span>)ch);&#125;</code></pre><ol start="2"><li>read(byte b[]，int a，int b)：从指定文件中的a位置开始，读取b个字符，存储到数组中</li><li>read(byte b[])：从指定文件中读取还未获取到的字符，存储到数组中，返回读取到的有效个数</li></ol><pre><code class="hljs java">StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>((len = fis.read(b)) != -<span class="hljs-number">1</span>)&#123;    sb.append(<span class="hljs-keyword">new</span> String(b,<span class="hljs-number">0</span>,len));&#125;System.out.println(sb);</code></pre><ol start="4"><li>close()：释放资源</li></ol></blockquote><blockquote><p>练习：将 D 盘中的图片，复制到 E 盘中</p><pre><code class="hljs java">FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;C:\\Users\\qianfeng\\Desktop\\a.png&quot;</span>);FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;E:\\b.png&quot;</span>);<span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>((len = fis.read(b)) != -<span class="hljs-number">1</span>)&#123;    fos.write(b,<span class="hljs-number">0</span>,len);&#125;fis.close();fos.close();</code></pre><p>注：流关闭的原则是“先开后管”</p></blockquote><h3 id="四filereader-文件字符输入流"><a class="markdownIt-Anchor" href="#四filereader-文件字符输入流"></a> 四，FileReader 文件字符输入流</h3><h4 id="41-概述"><a class="markdownIt-Anchor" href="#41-概述"></a> 4.1 概述</h4><blockquote><p>概述：该类是 Reader 的一个专门针对文件进行读取的流，它定义了一系列与读取相关的方法。</p></blockquote><h4 id="42-构造函数"><a class="markdownIt-Anchor" href="#42-构造函数"></a> 4.2 构造函数</h4><blockquote><ol><li>new FileReader(File f)</li><li>new FileReader(String name)</li></ol></blockquote><h4 id="43-常用方法"><a class="markdownIt-Anchor" href="#43-常用方法"></a> 4.3 常用方法</h4><blockquote><ol><li>read()</li><li>read(char ch[])</li><li>read(char ch[] ，int index，int lenth)</li><li>close()</li></ol></blockquote><h3 id="五filewriter-文件字符输出流"><a class="markdownIt-Anchor" href="#五filewriter-文件字符输出流"></a> 五，FileWriter 文件字符输出流</h3><h4 id="51-概念"><a class="markdownIt-Anchor" href="#51-概念"></a> 5.1 概念</h4><blockquote><p>概述：该类是 Writer 的一个专门针对文件进行写出的流，它定义了一系列与写出相关的方法。</p></blockquote><h4 id="52-构造函数"><a class="markdownIt-Anchor" href="#52-构造函数"></a> 5.2 构造函数</h4><blockquote><ol><li>new FileWriter(File f)</li><li>new FileWriter(String name)</li><li>new FileWriter(File f，boolean b)</li><li>new FileWriter(String name，boolean b)</li></ol></blockquote><h4 id="53-常用方法"><a class="markdownIt-Anchor" href="#53-常用方法"></a> 5.3 常用方法</h4><blockquote><ol><li>close()：释放资源，执行释放动作前，会先将缓冲区中的数据刷新到的目标位置</li><li>flush()：当使用 write() 方法写入文件时，只是把数据写入到了缓冲区中，需要用 flush() 才能将数据从缓冲区中真正的刷新到目标位置</li><li>write(int ch)</li><li>write(String str)</li><li>write(String str，int index，int length)</li><li>write(char[] ch)</li><li>write(char[] ch，int index，int length)</li></ol></blockquote><blockquote><p>close() 与 flush() 的区别：</p><p>flush() ：只是将数据从缓冲区中刷新到目标位置，刷新后，该输出流仍能正常使用</p><p>close()：会先将缓冲区中的数据刷新到的目标位置，再关闭资源，关闭后，该流不能再使用</p></blockquote><h3 id="六属性集-properties"><a class="markdownIt-Anchor" href="#六属性集-properties"></a> 六，属性集 Properties</h3><h4 id="61-概念"><a class="markdownIt-Anchor" href="#61-概念"></a> 6.1 概念</h4><blockquote><p>概念：Properties 是 HashTable 的一个子类，它用来表示持久的属性集，它使用键值对的方式存储数据。</p><p>注：</p><ol><li>Properties 一般用于读取配置文件</li><li>Properties 中的键和值的数据类型都是字符串类型的</li></ol></blockquote><h4 id="62-构造函数"><a class="markdownIt-Anchor" href="#62-构造函数"></a> 6.2 构造函数</h4><blockquote><ol><li>new Properties()</li></ol></blockquote><h4 id="63-常用方法"><a class="markdownIt-Anchor" href="#63-常用方法"></a> 6.3 常用方法</h4><blockquote><ol><li>setProperties(String key，String value)</li><li>getProperties(String key)</li><li>stringPropertyName()：返回当前 Properties 所有键组成的 Set 集合</li></ol></blockquote><h4 id="64-properties-与流相关的操作"><a class="markdownIt-Anchor" href="#64-properties-与流相关的操作"></a> 6.4 Properties 与流相关的操作</h4><blockquote><p>方法：</p><ol><li>void  load(InputStream)：从字节输入流中读取键值对，使用 Properties 加载流对象</li><li>void  load(Reader)：从字符输入流中读取键值对，使用 Properties 加载流对象</li></ol><pre><code class="hljs java"><span class="hljs-comment">// InputStream is = new FileInputStream(&quot;xxx&quot;); // 绝对路径</span><span class="hljs-comment">// InputStream is = new FileInputStream(&quot;src\\jdbc.properties&quot;);</span><span class="hljs-comment">// Reader is = new FileReader(&quot;E:\\workspace\\day26_02_流\\src\\jdbc.properties&quot;);</span>Reader is = <span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;src\\jdbc.properties&quot;</span>);prop.load(is);System.out.println(prop.getProperty(<span class="hljs-string">&quot;username&quot;</span>));System.out.println(prop.getProperty(<span class="hljs-string">&quot;password&quot;</span>));</code></pre><p>注：</p><p>Properties 读取的文件中的内容一般都是配置文件，配置文件以键值对的形式出现，格式：key=value、key:value、key value。</p></blockquote><h3 id="七缓冲流"><a class="markdownIt-Anchor" href="#七缓冲流"></a> 七，缓冲流</h3><h4 id="71-概念"><a class="markdownIt-Anchor" href="#71-概念"></a> 7.1 概念</h4><blockquote><p>概念：缓冲流，也称为高效流，它是对4个基本的 FileXxx 流的增强</p><p>分类：</p><ol><li>字节缓冲流：BufferedInputStream 字节缓冲输入流，BufferedOutputStream 字节缓冲输出流</li><li>字符缓冲流：BufferedReader 字符缓冲输入流，BufferedWriter 字符缓冲输出流</li></ol><p>缓冲流的原理：在创建流对象的同时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区的读写，减少IO操作的次数，从而提高读写效率。</p></blockquote><h4 id="72-构造函数"><a class="markdownIt-Anchor" href="#72-构造函数"></a> 7.2 构造函数</h4><blockquote><ol><li>BufferedReader br = new BufferedReader(Reader r)</li><li>BufferedWriter bw = new BufferedWriter(Writer w)</li><li>BufferedInputStream bis = new BufferedInputStream(InputStream is)</li><li>BufferedOutputStream bos = new BufferedOutputStream(OutputStream os)</li></ol></blockquote><blockquote><p>普通流和缓冲流的效率比较：</p><pre><code class="hljs java">&gt;<span class="hljs-comment">// 文件字节输入输出流</span>&gt;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;  FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;E:\\eclipse\\eclipse-jee-neon-R-win32-x86_64.zip&quot;</span>);  FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;C:\\Users\\qianfeng\\Desktop\\片子\\e.zip&quot;</span>);  <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;  <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];  <span class="hljs-keyword">while</span>((len = fis.read(b)) != -<span class="hljs-number">1</span>)&#123;      fos.write(b,<span class="hljs-number">0</span>,len);  &#125;  fos.close();  fis.close();&gt;&#125;&gt;<span class="hljs-comment">// 缓冲字节输入输出流</span>&gt;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;  FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;E:\\eclipse\\eclipse-jee-neon-R-win32-x86_64.zip&quot;</span>);  BufferedInputStream bis = <span class="hljs-keyword">new</span> BufferedInputStream(fis);  FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;C:\\Users\\qianfeng\\Desktop\\片子\\e.zip&quot;</span>);  BufferedOutputStream bos = <span class="hljs-keyword">new</span> BufferedOutputStream(fos);  <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;  <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];  <span class="hljs-keyword">while</span>((len = bis.read(b)) != -<span class="hljs-number">1</span>)&#123;      bos.write(b,<span class="hljs-number">0</span>,len);  &#125;  bos.close();  fos.close();  bis.close();  fis.close();&gt;&#125;</code></pre></blockquote><h4 id="73-常用方法"><a class="markdownIt-Anchor" href="#73-常用方法"></a> 7.3 常用方法</h4><blockquote><p>缓冲流中的方法与普通流中的方法基本相同</p><p>特有方法：</p><ol><li>BufferedReader 中的 readLine()：读取一整行</li><li>BufferedWriter 中的 newLine()：表示换行，自动适配当前操作系统</li></ol></blockquote><h4 id="74-练习"><a class="markdownIt-Anchor" href="#74-练习"></a> 7.4 练习</h4><blockquote><pre><code class="hljs angelscript"><span class="hljs-number">4.</span>低头思故乡。<span class="hljs-number">2.</span>疑似地上霜。<span class="hljs-number">1.</span>床前明月光，<span class="hljs-number">3.</span>举头望明月，<span class="hljs-comment">// 将其按照1234排序，输出到指定文件中</span></code></pre><p>方法一：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test1</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// 创建一个字符缓冲输入流，指向要排序的&quot;练习.txt&quot;</span>BufferedReader br = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;C:\\Users\\qianfeng\\Desktop\\练习.txt&quot;</span>));        <span class="hljs-comment">// 创建一个字符缓冲输出流，指向排序后输出的位置&quot;show.txt&quot;</span>BufferedWriter bw = <span class="hljs-keyword">new</span> BufferedWriter(<span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">&quot;C:\\Users\\qianfeng\\Desktop\\show.txt&quot;</span>));                <span class="hljs-comment">// 我们要通过每一条语句前的序号进行排序，并且排序时，每一天语句后的诗句要与序号同时进行排序</span>        <span class="hljs-comment">// Map中的键和值是一个整体，通过键就能获取值，可以对键进行排序，从而值也就排序了</span>HashMap&lt;String, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        String str = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">while</span>((str = br.readLine()) != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-comment">// split是String类中的切割功能，这个方法的参数是一个字符串，表示以何种方式进行切割，切割后返回的结果是一个字符串数组</span>String s[] = str.split(<span class="hljs-string">&quot;[.]&quot;</span>);map.put(s[<span class="hljs-number">0</span>], s[<span class="hljs-number">1</span>]);&#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= map.size() ;i++)&#123;String key = i + <span class="hljs-string">&quot;&quot;</span>;String value = map.get(key);String s = key + <span class="hljs-string">&quot;.&quot;</span> + value;bw.write(s);bw.newLine();&#125;        bw.close();br.close();&#125;&#125;</code></pre><p>方法二：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;BufferedReader br = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;C:\\Users\\qianfeng\\Desktop\\练习.txt&quot;</span>));BufferedWriter bw = <span class="hljs-keyword">new</span> BufferedWriter(<span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">&quot;C:\\Users\\qianfeng\\Desktop\\show.txt&quot;</span>));ArrayList&lt;QueryVo&gt; vos = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();String str = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">while</span>((str = br.readLine()) != <span class="hljs-keyword">null</span>)&#123;String[] s = str.split(<span class="hljs-string">&quot;\\.&quot;</span>);QueryVo vo = <span class="hljs-keyword">new</span> QueryVo();vo.num = s[<span class="hljs-number">0</span>];vo.msg = s[<span class="hljs-number">1</span>];vos.add(vo);&#125;System.out.println(vos);Collections.sort(vos);System.out.println(vos);<span class="hljs-keyword">for</span> (QueryVo vo : vos) &#123;String num = vo.num;String msg = vo.msg;String s = num + <span class="hljs-string">&quot;.&quot;</span>+msg;bw.write(s);bw.newLine();&#125;bw.close();&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QueryVo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">QueryVo</span>&gt;</span>&#123;String num;String msg;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(QueryVo o)</span> </span>&#123;<span class="hljs-comment">//return this.num.compareTo(o.num);</span><span class="hljs-keyword">return</span> Integer.valueOf(<span class="hljs-keyword">this</span>.num) - Integer.valueOf(o.num);&#125;&#125;</code></pre></blockquote><h3 id="八转换流"><a class="markdownIt-Anchor" href="#八转换流"></a> 八，转换流</h3><h4 id="81-字符编码和字符集"><a class="markdownIt-Anchor" href="#81-字符编码和字符集"></a> 8.1 字符编码和字符集</h4><blockquote><p>字符编码：在屏幕上看到的任何字符在计算机底层都是以某种规则转换成二进制的形式出现的，这种转换方式就叫做编码；将计算机底层的二进制数以某种规则显示在屏幕上的这种转换方式就叫做解码。如果转换规则错误，或者转换的规则不匹配就会发生乱码。</p><p>简单的说字符编码就是一套字符与二进制数转换的规则</p><p>字符集：也叫做编码表，它是系统支持的所有字符的一个集合，包含各个国家文字、标点符号、图形符号。</p><p>ASCII：它是基于拉丁字母的一套计算机编码系统，共有128个字符</p><p>ISO8859-1：拉丁码表，不包含中文</p><p>GB2312：GB是国标的意思，简体中文码表</p><p>GBK：最常用的中文码表，是在GB2312上的扩展，windows 操作系统的默认编码格式就是GBK</p><p>Unicode：万国码，满足跨语言、跨平台进行文本转换、处理的要求。</p><p>UTF-8：它可以用来表示Unicode标准中的任何字符，它逐渐成为电子邮箱、网页及其他存储或传送文字的应用中，优先采用的编码。</p></blockquote><h4 id="22-inputstreamreader"><a class="markdownIt-Anchor" href="#22-inputstreamreader"></a> 2.2 InputStreamReader</h4><h5 id="221-概述"><a class="markdownIt-Anchor" href="#221-概述"></a> 2.2.1 概述</h5><blockquote><p>概念：它是 Reader 的子类，它是从字节流转换到字符流的桥梁，它读取字节，并使用指定的字符集将其转换成字符。</p></blockquote><h5 id="222-构造函数"><a class="markdownIt-Anchor" href="#222-构造函数"></a> 2.2.2 构造函数</h5><blockquote><ol><li>new InputStreamReader(InputStream in)</li><li>new InputStreamReader(InputStream in，String charset)</li></ol></blockquote><h4 id="23-outputstreamwriter"><a class="markdownIt-Anchor" href="#23-outputstreamwriter"></a> 2.3 OutputStreamWriter</h4><h5 id="231-概述"><a class="markdownIt-Anchor" href="#231-概述"></a> 2.3.1 概述</h5><blockquote><p>概述：它是 Writer 的子类，它的从字符流转换到字节流的桥梁，它读取字符，并使用指定的字符集将字符转换成字节。</p></blockquote><h5 id="232-构造函数"><a class="markdownIt-Anchor" href="#232-构造函数"></a> 2.3.2 构造函数</h5><blockquote><ol><li>new OutputStreamWriter(OutputStream os)</li><li>new OutputStreamWriter(OutputStream os，String charset)</li></ol></blockquote><h4 id="24-代码"><a class="markdownIt-Anchor" href="#24-代码"></a> 2.4 代码</h4><blockquote><pre><code class="hljs java">&gt;FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;C:\\Users\\qianfeng\\Desktop\\test.txt&quot;</span>);&gt;InputStreamReader isr = <span class="hljs-keyword">new</span> InputStreamReader(fis,<span class="hljs-string">&quot;utf-8&quot;</span>);&gt;<span class="hljs-keyword">int</span> ch = <span class="hljs-number">0</span>;&gt;<span class="hljs-keyword">while</span>((ch = isr.read()) != -<span class="hljs-number">1</span>)&#123;   System.out.println((<span class="hljs-keyword">char</span>)ch);&gt;&#125;&gt;isr.close();&gt;System.out.println(<span class="hljs-string">&quot;------------------------------&quot;</span>);&gt;FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;C:\\Users\\qianfeng\\Desktop\\demo.txt&quot;</span>);&gt;OutputStreamWriter osw = <span class="hljs-keyword">new</span> OutputStreamWriter(fos, <span class="hljs-string">&quot;utf-8&quot;</span>);&gt;osw.write(<span class="hljs-string">&quot;你好&quot;</span>);&gt;osw.close();</code></pre><p>注：字符集的选用根据读写的目标文件决定</p></blockquote><h3 id="九对象流-序列化流"><a class="markdownIt-Anchor" href="#九对象流-序列化流"></a> 九，对象流 （序列化流）</h3><h4 id="91-序列化"><a class="markdownIt-Anchor" href="#91-序列化"></a> 9.1 序列化</h4><blockquote><p>Java 中提供了一种对象的序列化机制，允许将一个对象及其属性持久化的存储到文件中。</p><p>序列化：将对象存储到文件中</p><p>反序列化，将文件中的对象解析出来</p></blockquote><h4 id="92-objectoutputstream"><a class="markdownIt-Anchor" href="#92-objectoutputstream"></a> 9.2 ObjectOutputStream</h4><blockquote><p>构造方法：new ObjectOutputStream(OutputStream out)</p><p>注：</p><ol><li>一个类中的对象要想序列化，该类必须实现 Serializable 接口，这个接口是一个标记接口，不实现此接口的类不能序列化和反序列化，会发生 NotSerializableException。</li><li>如果不想让某个属性被序列化，可以使用 transient 瞬态关键字修饰。</li></ol><pre><code class="hljs java">Person p = <span class="hljs-keyword">new</span> Person();p.name = <span class="hljs-string">&quot;乔碧萝&quot;</span>;p.age = <span class="hljs-number">25</span>;p.sex = <span class="hljs-string">&quot;男&quot;</span>;ObjectOutputStream oos = <span class="hljs-keyword">new</span> ObjectOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;C:\\Users\\qianfeng\\Desktop\\demo.txt&quot;</span>));oos.writeObject(p); <span class="hljs-comment">// 写入对象的核心方法</span>oos.close();</code></pre></blockquote><h4 id="92-objectinputstream"><a class="markdownIt-Anchor" href="#92-objectinputstream"></a> 9.2 ObjectInputStream</h4><blockquote><p>构造方法：new ObjectInputStream(InputStream out)</p><pre><code class="hljs java">ObjectInputStream ois = <span class="hljs-keyword">new</span> ObjectInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;C:\\Users\\qianfeng\\Desktop\\demo.txt&quot;</span>));Person pp = (Person)ois.readObject(); <span class="hljs-comment">// 读取对象的核心方法</span>System.out.println(pp.name);System.out.println(pp.age);System.out.println(pp.sex);</code></pre><p>注：如果读取对象的次数超过了对象的个数，会发生 EOFException</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>文件</title>
    <link href="/2019/02/15/%E6%96%87%E4%BB%B6/"/>
    <url>/2019/02/15/%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="一文件"><a class="markdownIt-Anchor" href="#一文件"></a> 一，文件</h3><h4 id="11-文件的概述"><a class="markdownIt-Anchor" href="#11-文件的概述"></a> 1.1 文件的概述</h4><blockquote><p>概念：File 是文件或者文件夹的抽象表示形式</p></blockquote><h4 id="12-构造函数"><a class="markdownIt-Anchor" href="#12-构造函数"></a> 1.2 构造函数</h4><blockquote><ol><li>new File(String pathname)</li><li>new File(String parent, String child)</li><li>new File(File parent, String child)</li></ol></blockquote><h4 id="13-常用方法"><a class="markdownIt-Anchor" href="#13-常用方法"></a> 1.3 常用方法</h4><blockquote><ol><li><p>获取相关</p><ol><li>getPath()：获取路径，返回结果与创建时的路径表示形式相同</li><li>getAbsolutePath()：获取绝对路径，无论创建时使用的是相对路径还是绝对路径，返回的都是绝对路径</li><li>getParent()：返回父目录的地址</li><li>getParentFile()：返回父目录文件的对象</li><li>getName()：返回文件名（包含后缀）</li><li>length()：返回文件大小，单位是字节</li></ol></li><li><p>判断相关</p><ol><li>exists()：判断文件或者文件夹是否存在</li><li>isFile()：判断是否是文件</li><li>isDirectory()：判断是否是目录</li></ol><p>注：如果文件或者文件夹不存在，那么无论是判断是文件还是目录返回的都是 false</p><ol start="4"><li>canRead()：判断是否可读</li><li>canWrite()：判断是否可写</li><li>canExecute()：判断是否可执行</li><li>isHidden()：判断文件或者文件夹是否隐藏</li></ol></li><li><p>创建和删除相关</p><ol><li>createNewFile()：如果指定文件不存在，则创建一个指定文件名的文件，返回 true；如果已存在，则不创建，返回 false</li><li>mkdir()：创建一个文件夹（只能创建单层目录），返回 false 表示创建失败，true 表示成功</li><li>mkdirs()：创建一个文件夹（可以创建多级目录），返回 false 表示创建失败，true 表示成功</li><li>delete()：删除文件或者文件夹，，返回 false 表示删除失败，true 表示成功，如果文件夹中含有内容，那么该文件夹不能删除</li><li>deleteOnExit()：删除文件或者文件夹，在程序运行完毕后执行该删除操作，如果文件夹中含有内容，那么该文件夹不能删除</li></ol></li><li><p>文件夹的遍历</p><ol><li>list()：返回指定目录下所有文件或者文件夹的名字组成的数组</li><li>listFiles()：返回指定目录下所有文件对象组成的数组</li><li>list(FilenameFilter filter)：根据指定的文件名过滤器获取指定文件，将它们的名字组成数组</li><li>listFile(FilenameFilter filter)：根据指定的文件名过滤器获取指定文件，将这些文件对象组成数组</li></ol></li></ol></blockquote><h3 id="二文件夹的递归"><a class="markdownIt-Anchor" href="#二文件夹的递归"></a> 二，文件夹的递归</h3><blockquote><p>递归的概念：在方法中调用自身</p><p>注：</p><ol><li>递归要有限定条件，保证递归能够停止，否则会发生 StackOverflowError</li><li>在不断递归的过程中，数据范围要不断减小</li><li>递归的性能很差</li></ol><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">search</span><span class="hljs-params">(File file)</span></span>&#123;    <span class="hljs-keyword">for</span>(File f : file.listFiles())&#123;        <span class="hljs-keyword">if</span>(f.isFile())&#123;            <span class="hljs-keyword">if</span>(f.getName().endsWith(<span class="hljs-string">&quot;.mp3&quot;</span>))&#123;                System.out.println(f);            &#125;        &#125;<span class="hljs-keyword">else</span>&#123;            search(f);        &#125;    &#125;&#125;</code></pre><p>使用 FileNameFilter 接口进行文件名的过滤：</p><p>使用步骤：</p><ol><li>自定义类实现 FileNameFilter 接口</li><li>重写 accpet() 方法，该方法有两个参数：<ol><li>File dir：表示当前文件夹</li><li>String name：表示当前文件夹中遍历到的某一个文件的文件名</li></ol></li><li>将该实现类的对象作为参数传递到 list() 或者 listFiles() 中</li></ol><pre><code class="hljs java"><span class="hljs-comment">// 实现类的方式</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NameFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">FilenameFilter</span> </span>&#123;<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">accept</span><span class="hljs-params">(File dir, String name)</span> </span>&#123;<span class="hljs-comment">/*</span><span class="hljs-comment"> * System.out.println(&quot;dir：&quot;+dir);</span><span class="hljs-comment"> * System.out.println(&quot;name：&quot;+name+&quot;---&quot;+i++);</span><span class="hljs-comment"> */</span><span class="hljs-keyword">return</span> name.endsWith(<span class="hljs-string">&quot;.mp3&quot;</span>);&#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">// 匿名内部类的方式</span>File f2 = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;E:\\demo&quot;</span>);File[] files2 = f2.listFiles(<span class="hljs-keyword">new</span> FilenameFilter() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">accept</span><span class="hljs-params">(File dir, String name)</span> </span>&#123;        <span class="hljs-keyword">return</span> name.endsWith(<span class="hljs-string">&quot;.mp3&quot;</span>);    &#125;&#125;);<span class="hljs-keyword">for</span> (File file : files2) &#123;    System.out.println(file);&#125;</code></pre></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>多线程</title>
    <link href="/2019/02/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2019/02/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="一多线程的概念"><a class="markdownIt-Anchor" href="#一多线程的概念"></a> 一，多线程的概念</h3><blockquote><p>进程：正在运行的程序</p><p>线程：是进程中的一个执行单元（一条执行路径），一个进程中至少包含一个线程。如果一个进程中有多个线程，这样的程序就称为多线程程序。</p><p>线程的调度：</p><ol><li>分时调度：所有线程轮流使用CPU，每个线程平均占用CPU的时间</li><li>抢占式调度：优先让优先级高的线程使用CPU，如果线程的优先级相同，那么随机选择一个线程为其分配CPU的资源（随机性），Java 多线程的执行方式就是抢占式的。</li></ol><p>注：</p><ol><li>Java 程序在没有开辟新线程的情况下也会有两个线程：主函数所在的主线程、垃圾回收线程</li></ol></blockquote><h3 id="二创建线程"><a class="markdownIt-Anchor" href="#二创建线程"></a> 二，创建线程</h3><blockquote><p>方式一：继承 Thread 类</p><ol><li>自定义类继承 Thread 类</li><li>重写 run() 方法，在 run() 中明确线程执行的功能</li><li>创建 Thread 的子类对象</li><li>使用这个子类对象调用 start() 方法开启线程，JVM 会自动调用重写后的 run() 方法</li></ol><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test1</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;MyThread mt = <span class="hljs-keyword">new</span> MyThread();mt.start();MyThread mt2 = <span class="hljs-keyword">new</span> MyThread();mt2.start();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= <span class="hljs-number">100</span>;i++)&#123;System.out.println(<span class="hljs-string">&quot;main方法：&quot;</span>+i);&#125;&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<span class="hljs-comment">// 重写run()方法是为了明确线程中所执行的任务</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= <span class="hljs-number">100</span>;i++)&#123;System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;---&quot;</span>+i);&#125;&#125;&#125;</code></pre><p>方式二：实现 Runnable 接口</p><ol><li>自定义类实现 Runnable 接口</li><li>重写 run() 方法，在 run() 中明确线程执行的功能</li><li>创建 Runnable 实现类的对象</li></ol><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;MyRunnable mr = <span class="hljs-keyword">new</span> MyRunnable();Thread t = <span class="hljs-keyword">new</span> Thread(mr);t.start();Thread t2 = <span class="hljs-keyword">new</span> Thread(mr);t2.start();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= <span class="hljs-number">300</span>;i++)&#123;System.out.println(<span class="hljs-string">&quot;main方法：&quot;</span>+i);&#125;&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">300</span>;i++)&#123;System.out.println(Thread.currentThread()+<span class="hljs-string">&quot;--&quot;</span>+i);&#125;&#125;&#125;</code></pre></blockquote><p>方式三：实现Callable接口</p><p>可以有结果返回值</p><blockquote><p>继承 Thread 类 和 实现 Runnable 接口的选用：</p><p>使用实现的方式，因为避免了单继承的局限性</p><p>注：同一个线程对象不能重复开启，重复开启会发生 IllegalThreadStateException</p></blockquote><blockquote><p>使用匿名内部类的方式创建线程并开启：</p><ol><li><pre class="highlight"><code class="java"><span class="hljs-keyword">new</span> Thread()&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">// 线程执行的任务</span>    &#125;&#125;.start();&lt;!--code￼<span class="hljs-number">2</span>--&gt;</code></pre></li></ol></blockquote><h3 id="三线程中的方法"><a class="markdownIt-Anchor" href="#三线程中的方法"></a> 三，线程中的方法</h3><blockquote><ol><li><p>String getName()：返回线程的名称</p></li><li><p>static Thread currentThread()：返回线程对象，</p><p>Thread [ Thread - 0 , 5 , main]</p><ol><li>Thread - 0：线程的名称</li><li>5：优先级</li><li>main：在主函数中开启的</li></ol></li><li><p>static void sleep(long time)</p></li></ol></blockquote><h3 id="四线程安全问题"><a class="markdownIt-Anchor" href="#四线程安全问题"></a> 四，线程安全问题</h3><blockquote><p>什么是线程安全：如果有多个线程同时执行，这些线程同时操作同一个内容，程序运行后的结果和单线程运行的结果是一样的时候，就称为线程安全。</p></blockquote><blockquote><p>完成 3 个窗口同时卖票案例时，发现了重复票和负数票的情况，原因是多个线程在操作同一个 ticket 变量，</p><p>在某个线程通过了 if 判断后，被其他线程抢夺了 CPU 的执行权，所以 if 后的 ticket--  操作，在一次判断后重复执行了多次。</p></blockquote><blockquote><p>解决方式：</p><ol><li><p>同步代码块</p><p>格式：</p><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(锁对象)&#123;    <span class="hljs-comment">// 可能发生线程安全问题的代码</span>&#125;</code></pre><p>注：</p><ol><li>同步代码块中的锁对象可以是任意的</li><li>必须保证多个线程使用的锁对象是同一个</li><li>锁对象的作用：将同步代码块锁定，同一时间只允许让一个线程进入同步代码块</li></ol></li><li><p>同步函数</p><p>步骤：</p><ol><li>将可能发生线程安全问题的代码抽取到一个方法中</li><li>再在这个方法上添加 synchronized 修饰符</li></ol><p>格式：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> 返回类型 方法名(参数)&#123;    <span class="hljs-comment">// 可能发生线程安全问题的代码</span>&#125;</code></pre><p>注：</p><ol><li><p>同步函数中有锁吗？有，同步函数中的锁是 this</p></li><li><p>在使用继承 Thread 的方式去创建线程时，使用同步函数不能保证线程同步，因为每一个线程对象都有属于自己的一份 this，所以多个线程使用的不是同一个锁</p><p>解决办法：使用 static 修饰同步函数，此时同步函数中的锁还是 this 吗？</p><p>不是，因为 static 不能访问 this，锁是 类名.class</p></li></ol></li><li><p>Lock 锁：</p><ol><li>Lock 是一个接口，在 jdk 1.5 后出现，它使用了比 synchronized 更简单更广泛的锁的操作方式</li><li>方法：lock() 获取锁，unlock() 释放锁</li><li>步骤：<ol><li>在成员位置创建 ReentrantLock 对象</li><li>在可能会发生线程安全问题前调用 lock() 获取锁</li><li>在可能会发生线程安全问题后调用 unlock() 释放锁</li></ol></li></ol></li></ol><p>同步技术的原理：</p><p>同步技术中使用到了锁对象，这个锁对象也称为同步锁</p><p>多个线程一起抢夺 CPU 的执行权，谁抢到了，谁就能进入同步代码块，</p><p>当一个线程抢夺到了 CPU 的执行权时，会判断是否有锁对象，</p><p>如果有锁对象，就会获取到这个锁，进入同步代码块，当这个线程执行完同步代码块，就会释放锁</p><p>如果没有锁对象，会处于阻塞状态，等待其他线程执行完同步代码块，等待其他线程释放锁，才能再进行 CPU 执行权的抢夺</p><p>使用同步锁会影响程序的执行效率：</p><p>因为获取 CPU 执行权的线程，在进入同步代码块之前，需要判断是否有锁，</p><p>如果有锁还需要进行获取的动作，</p><p>在执行完同步代码块后，需要释放锁。</p><p>（判断锁，获取锁，释放锁）</p></blockquote><h3 id="五线程池"><a class="markdownIt-Anchor" href="#五线程池"></a> 五，线程池</h3><h4 id="51-问题"><a class="markdownIt-Anchor" href="#51-问题"></a> 5.1 问题</h4><blockquote><p>在每次使用线程时，都需要创建线程对象，操作方式非常简便，但是存在一个问题：</p><p>如果并发的线程数量很多，每个线程执行完一个时间很短的任务就结束了，这样频繁创建线程会极大的降低程序的性能。</p><p>所以我们需要想一个办法能重复利用已创建的线程，来避免线程的过多创建。</p></blockquote><h4 id="52-概念"><a class="markdownIt-Anchor" href="#52-概念"></a> 5.2 概念</h4><blockquote><p>线程池本质上就是一个可以存放多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作。</p></blockquote><h4 id="53-好处"><a class="markdownIt-Anchor" href="#53-好处"></a> 5.3 好处</h4><blockquote><ol><li>降低资源消耗，减少了创建线程的次数，每个线程都可以被重复利用</li><li>提高程序的响应速度</li><li>提高了对线程的管理</li></ol></blockquote><h4 id="54-实现步骤"><a class="markdownIt-Anchor" href="#54-实现步骤"></a> 5.4 实现步骤</h4><blockquote><ol><li>使用线程池的工厂类 Executors 中的静态方法 newFixedThreadPool 创建一个包含指定线程数量的线程池 ExecutorService</li><li>创建 Runnable 接口的实现类，重写 run() 方法</li><li>调用 ExecutorService 中的 submit() 方法，传入实现类对象，该方法用于开启线程并调用 run() 方法</li><li>调用 ExecutorService  中的 shutdown() 方法，来销毁线程池，一旦被销毁，就无法再从池中获取线程对象</li></ol></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>集合框架</title>
    <link href="/2019/02/12/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    <url>/2019/02/12/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="一集合的概述"><a class="markdownIt-Anchor" href="#一集合的概述"></a> 一，集合的概述</h3><blockquote><p>概念：集合是一种用于存储数据的容器</p><p>特点：</p><ol><li>集合的长度是可变的</li><li>集合中存储的数据类型是任意的</li><li>集合不能存储基本数据类型，要存储对应的包装类</li><li>同一个集合中可以存储不同类型的数据</li><li>在定义集合时，要明确集合的泛型，泛型：集合中可以存储的指定类型</li></ol></blockquote><h3 id="二集合的体系结构"><a class="markdownIt-Anchor" href="#二集合的体系结构"></a> 二，集合的体系结构</h3><blockquote><p>Collection接口是整个集合体系中的根接口</p><p>​它定义了集合的共性方法</p><ol><li>add()</li><li>addAll()</li><li>remove()</li><li>removeAll()</li><li>isEmpty()</li><li>size()</li><li>clear()</li><li>contains()</li><li>containsAll()</li></ol><p>Collection 的子接口</p><ol><li>List 接口<ol><li>有序的（存储顺序与访问顺序一致）</li><li>可以重复</li><li>常见的实现类：ArrayList、LinkedList、Vector</li></ol></li><li>Set 接口<ol><li>有些 Set 有序，有些 Set 无序（无序：访问顺序不能保证与存储顺序一致）</li><li>不可重复</li><li>常用的实现类：HashSet、LinkedHashSet、TreeSet</li></ol></li></ol></blockquote><h3 id="三arraylist-集合"><a class="markdownIt-Anchor" href="#三arraylist-集合"></a> 三，ArrayList 集合</h3><h4 id="31-概念"><a class="markdownIt-Anchor" href="#31-概念"></a> 3.1 概念</h4><blockquote><p>概念：ArrayList 集合是 List 接口的一个实现类，它的存储结构是数组结构，是日常开发中使用频率最高的一种 List 集合。ArrayList 的特点是查询快，增删慢。</p></blockquote><h4 id="32-构造函数"><a class="markdownIt-Anchor" href="#32-构造函数"></a> 3.2 构造函数</h4><blockquote><ol><li>new ArrayList()：构造一个初始容量为 10 的空列表。</li><li>new ArrayList(int capacity)：构造一个具有指定初始容量的空列表。</li></ol></blockquote><h4 id="33-常用方法"><a class="markdownIt-Anchor" href="#33-常用方法"></a> 3.3 常用方法</h4><blockquote><ol><li>add(E e)：将元素添加到集合的末尾，返回布尔值；如果是 List 的 add() 返回值一定是 true，如果是 Set 的add() ，当元素已存在时会返回 false</li><li>add(int index,  E e)：将元素添加集合中的指定位置，返回 void</li><li>remove(E e)：从集合中移除指定对象，返回是否移除成功的布尔值</li><li>remove(int index)：从集合中移除指定位置上的对象，返回被移除的对象</li><li>set(int index, E e)：用指定元素替换集合中指定位置上的元素</li><li>get(int index)：通过下标返回元素</li><li>size()：返回集合的大小</li><li>addAll(Collecrtion c)</li><li>addAll(int index, Collection c)</li><li>containsAll(Collection c)：判断参数集合中的所有元素是否都存在于调用者集合中</li><li>a . retainAll( b )：将 a、b两个集合的交集替换掉 a 集合中的所有元素，返回 true 表示 a 集合发生了改变</li><li>a . removeAll( b )：从 a 集合中移除 a、b 集合的交集，返回 true 表示 a 集合发生了改变</li><li>clear()</li><li>contains(E e)</li><li>indexOf(Object o)</li><li>lastIndexOf(Object o)</li><li>isEmpty()</li></ol></blockquote><h4 id="33-遍历方式"><a class="markdownIt-Anchor" href="#33-遍历方式"></a> 3.3 遍历方式</h4><blockquote><ol><li>普通 for 循环</li></ol><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt;= list.size() - <span class="hljs-number">1</span>;i++)&#123;    System.out.println(i + <span class="hljs-string">&quot;==&quot;</span> +list.get(i));&#125;</code></pre><ol start="2"><li>增强 for 循环</li></ol><pre><code class="hljs java"><span class="hljs-keyword">for</span>(String s : list)&#123;    System.out.println(s);&#125;</code></pre></blockquote><h3 id="四linkedlist-集合"><a class="markdownIt-Anchor" href="#四linkedlist-集合"></a> 四，LinkedList 集合</h3><h4 id="41-概念"><a class="markdownIt-Anchor" href="#41-概念"></a> 4.1 概念</h4><blockquote><p>概念：LinkedList 集合是 List 接口的一个实现类，它的存储结构是链表结构，LinkedList 的特点是增删快，查询慢。</p></blockquote><h4 id="42-构造函数"><a class="markdownIt-Anchor" href="#42-构造函数"></a> 4.2 构造函数</h4><blockquote><ol><li>new LinkedList()：构造一个空列表</li></ol></blockquote><h4 id="43-方法"><a class="markdownIt-Anchor" href="#43-方法"></a> 4.3 方法</h4><blockquote><p>注：在 ArrayList 中所具备的方法，在 LinkedList 中都有，如果想要调用 LinkedList 中的特有方法，不可以使用多态的形式创建 LinkedList 对象。</p><p>LinkedList 的特有方法：</p><ol><li>addFirst(E e)</li><li>addLast(E e)</li><li>remove()</li><li>removeFirst()</li><li>removeLast()</li><li>peek()</li><li>peekFirst()</li><li>peekLast()</li><li>pop()</li><li>poll()</li><li>push(E e)</li></ol></blockquote><h3 id="五arraylist-和-linkedlist-的区别"><a class="markdownIt-Anchor" href="#五arraylist-和-linkedlist-的区别"></a> 五，ArrayList 和 LinkedList 的区别</h3><blockquote><p>ArrayList 底层是数组结构的，查询快、增删慢</p><p>LinkedList 底层是链表结构的，增删快、查询慢</p></blockquote><h3 id="六-list-的嵌套"><a class="markdownIt-Anchor" href="#六-list-的嵌套"></a> 六， List 的嵌套</h3><blockquote><p>定义格式：</p><pre><code class="hljs java"><span class="hljs-comment">// 以 ArrayList 为例</span>ArrayList&lt;ArrayList&lt;String&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</code></pre><p>遍历方式：</p><pre><code class="hljs java"><span class="hljs-comment">// 以 ArrayList 为例</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt;= list.size() - <span class="hljs-number">1</span> ; i++)&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span> ; j &lt;= list.get(i).size() - <span class="hljs-number">1</span> ; j++)&#123;    &#125;&#125;<span class="hljs-keyword">for</span>(ArrayList&lt;String&gt; l : list)&#123;    <span class="hljs-keyword">for</span>(String s : l)&#123;    &#125;&#125;</code></pre></blockquote><h3 id="七-集合工具类-colletions"><a class="markdownIt-Anchor" href="#七-集合工具类-colletions"></a> 七， 集合工具类 Colletions</h3><blockquote><p>注：Collections 中的方法都是静态方法</p><ol><li>sort(List l)</li><li>shuffle(List l)</li><li>replaceAll(List l , oldValue, newValue)</li><li>reverse(List l)</li><li>max(List l)</li><li>min(List l)</li><li>swap(List l, int index1, int index2)</li><li>copy(List newList ,  List oldList)</li><li>fill(List l ,  E e)</li><li>addAll(Collection c, E … e)</li></ol></blockquote><h3 id="八-vector"><a class="markdownIt-Anchor" href="#八-vector"></a> 八， Vector</h3><blockquote><p>概念：Vector 是 List 的一个实现类，它的 API 大致与 ArrayList 一致，区别是 Vector 是同步的，保证线程安全。</p></blockquote><h3 id="九set-集合"><a class="markdownIt-Anchor" href="#九set-集合"></a> 九，Set 集合</h3><blockquote><p>概念：Set 集合是 Collection 接口一个子接口</p><p>特点：</p><ol><li>不允许有重复元素</li><li>没有下标，没有使用下标作为参数的相关方法，因此 Set 集合不能使用普通 for 循环进行遍历</li></ol></blockquote><h3 id="十-hashset-集合"><a class="markdownIt-Anchor" href="#十-hashset-集合"></a> 十， HashSet 集合</h3><blockquote><p>概念：HashSet 集合是 Set 集合的一个实现类</p><p>特点：</p><ol><li>不允许有重复元素</li><li>没有下标，没有使用下标作为参数的相关方法，因此 Set 集合不能使用普通 for 循环进行遍历</li><li>它是一个无序的集合，存取顺序不能保证一致</li><li>底层结构是哈希表，哈希结构的特点是查询速度快<ol><li>jdk 1.8 之前，哈希表 = 数组 + 链表</li><li>jdk 1.8 及之后，哈希表 = 数组 + 链表（当链表的长度超过8个，会将链表结构转换成红黑树）</li></ol></li></ol></blockquote><blockquote><p>哈希值：是一个十进制数，由系统随机给出的一个值，它是根据地址模拟出来的一个值。</p><p>在 Object 类有一个 hashCode() 方法可以获取对象的哈希值。</p><p>hashCode()源码：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span></span>;</code></pre><p>native：表示这个方法调用的是本地操作系统的方法</p></blockquote><blockquote><p>HashSet 的存储原理：</p><p>向 HashSet 存储对象时，先判断集合中是否存在与该对象相同的 哈希值 ，如果没有，那么直接存储；如果集合中已经存在某些对象的 哈希值 与要添加对象的 哈希值 相同，那么会继续调用对象的 equals() 方法，如果返回为 true，则不存储，为 false，则存储。</p><p>如何使用 HashSet 在存储自定义数据类型时，保证对象唯一</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> prime = <span class="hljs-number">31</span>;    <span class="hljs-keyword">int</span> result = <span class="hljs-number">1</span>;    result = prime * result + age;    result = prime * result + ((name == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : name.hashCode());    <span class="hljs-keyword">return</span> result;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span> </span>&#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == obj)        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    <span class="hljs-keyword">if</span> (obj == <span class="hljs-keyword">null</span>)        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">if</span> (getClass() != obj.getClass())        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    Person other = (Person) obj;    <span class="hljs-keyword">if</span> (age != other.age)        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">if</span> (name == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">if</span> (other.name != <span class="hljs-keyword">null</span>)            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!name.equals(other.name))        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre></blockquote><h3 id="十一-自定义类的排序"><a class="markdownIt-Anchor" href="#十一-自定义类的排序"></a> 十一， 自定义类的排序</h3><blockquote><p>如果想要将集合中自定义类的对象进行升降序的排列，可以通过两种方法实现：</p><ol><li><p>实现 Comparable 接口</p><p>步骤：</p><ol><li><p>实现 Comparable 接口</p><ol start="2"><li>重写 public int compareTo (T t) 方法</li><li>根据升降序的要求返回属性值的差值，降序：参数对象的属性 - 调用者的属性；升序：调用者的属性 - 参数对象的属性</li></ol></li></ol></li><li><p>调用 sort() 方法传入 Comparator 接口的实现类对象</p><p>步骤：</p><ol><li>调用 sort(List l, Comparator  c) 方法，在第一个参数中传入要比较的集合</li><li>创建 Comparator  接口的实现类对象，并重写 int compare(T t1, T t2)；</li><li>根据升降序的要求返回属性值的差值，降序：t2 的属性 - t1 的属性；升序：t1 的属性 - t2 的属性</li></ol></li></ol><p>注：数组中存储自定义数据类型也可以使用上述方法进行属性值的排序</p></blockquote><h3 id="十二迭代器"><a class="markdownIt-Anchor" href="#十二迭代器"></a> 十二，迭代器</h3><blockquote><p>概念：迭代器是 Collection 集合中元素获取的通用方法。</p><p>原理：在获取元素前先判断集合中有没有下一个可以获取的元素，如果有，就把这个元素取出来，继续判断，如果还有就再取出来，直到没有下一个可获取的元素。这种元素的获取方式就称为迭代。</p></blockquote><blockquote><p>迭代器接口：Iterator，它在 java.util 包中</p><p>常用方法：</p><ol><li>hasNext()：判断集合中是否存在下一个可以获取的元素</li><li>next()：取出下一个元素</li></ol><p>迭代器的使用步骤：</p><ol><li>调用 List 或者 Set 的 iterator() 方法，获取迭代器对象，这个迭代器的获取方式是通过 List 或者 Set 对象进行调用的，因此这个迭代器就与调用它的集合进行了绑定（关联），此时这个迭代器迭代的就是调用它的集合。</li><li>调用迭代器的 hasNext() 方法，判断是否存在下一个可以获取的元素</li><li>调用迭代器的 next() 方法，获取下一个元素</li></ol><pre><code class="hljs java">ArrayList&lt;String&gt; list =  <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();list.add(<span class="hljs-string">&quot;a&quot;</span>);list.add(<span class="hljs-string">&quot;b&quot;</span>);list.add(<span class="hljs-string">&quot;c&quot;</span>);list.add(<span class="hljs-string">&quot;d&quot;</span>);Iterator&lt;String&gt; it = list.iterator();<span class="hljs-keyword">while</span>(it.hasNext())&#123;    System.out.println(it.next());&#125;HashSet&lt;String&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();set.add(<span class="hljs-string">&quot;郭敬明&quot;</span>);set.add(<span class="hljs-string">&quot;蔡徐坤&quot;</span>);set.add(<span class="hljs-string">&quot;乔碧萝&quot;</span>);set.add(<span class="hljs-string">&quot;吴亦凡&quot;</span>);Iterator&lt;String&gt; iter = set.iterator();<span class="hljs-keyword">while</span>(iter.hasNext())&#123;    System.out.println(iter.next());&#125;</code></pre><p>注：</p><ol><li><p>Iterator 迭代器也是有泛型的，集合的泛型是什么类型，迭代器的泛型就是什么类型</p></li><li><p>迭代器是所有 Collection 遍历的通用方法</p></li><li><p>迭代器在迭代的过程中不可以对元素进行增删</p><p>解决办法：使用 Iterator 的子接口 ListIterator</p><p>在迭代器期间可以使用 ListIterator 的 add()、remove() 方法进行元素的增删</p><pre><code class="hljs java">ArrayList&lt;String&gt; list =  <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();list.add(<span class="hljs-string">&quot;a&quot;</span>);list.add(<span class="hljs-string">&quot;b&quot;</span>);list.add(<span class="hljs-string">&quot;c&quot;</span>);list.add(<span class="hljs-string">&quot;d&quot;</span>);ListIterator&lt;String&gt; lit = list.listIterator();<span class="hljs-keyword">while</span>(lit.hasNext())&#123;    <span class="hljs-keyword">if</span>(lit.next().equals(<span class="hljs-string">&quot;b&quot;</span>))&#123;        <span class="hljs-comment">//lit.remove();</span>        lit.add(<span class="hljs-string">&quot;B&quot;</span>);    &#125;&#125;System.out.println(list);</code></pre></li></ol></blockquote><h3 id="十三-linkedhashset"><a class="markdownIt-Anchor" href="#十三-linkedhashset"></a> 十三， LinkedHashSet</h3><blockquote><p>概念：LinkedHashSet 是 Set 集合的一个有序的实现类</p><p>能保持有序（存取顺序一致）的原理是 LinkedHashSet 在 HashSet 上多加了一条用于记录顺序的链表</p></blockquote><h3 id="十四-treeset"><a class="markdownIt-Anchor" href="#十四-treeset"></a> 十四， TreeSet</h3><blockquote><p>概念：TreeSet 是 Set 集合的一个能自动排序的实现类</p><p>注：如果 TreeSet 中的元素对象是自定义类，那么这个类必须实现 Comparable 接口，重写 compareTo()方法</p></blockquote><h3 id="十五泛型"><a class="markdownIt-Anchor" href="#十五泛型"></a> 十五，泛型</h3><blockquote><p>概念：当无法确定类型时，可以使用泛型来表示要操作的数据类型，写在 &quot; &lt;&gt; &quot; 中</p><p>泛型也可以看成是一个参数，用来接收数据类型</p><p>当泛型确定下来后，那么所能操作的数据类型就是该指定类型了</p></blockquote><blockquote><p>创建集合，不使用泛型：</p><p>好处：默认类型是 Object ，可以存储任意的数据类型</p><p>弊端：调用不同类型的功能时候，可能发生异常</p><p>创建集合，使用泛型：</p><p>好处：</p><p>​1. 避免了类型转换异常</p><pre><code>  2. 把运行时期的异常，放到了编译时期</code></pre><p>弊端：泛型是什么类型，就只能存储什么类型</p></blockquote><blockquote><p>泛型通配符：</p><p>当使用泛型时，泛型不确定，可以使用通配符 ? 来表示</p><p>泛型通配符的使用，是在受限泛型中：</p><ol><li>泛型的上限</li></ol><p>格式：</p><pre><code class="hljs java">&lt; ? extends 类名 &gt;</code></pre><p>限制：只能接收指定类型及其子类</p><ol start="2"><li>泛型的下限</li></ol><p>格式：</p><pre><code class="hljs java">&lt; ? <span class="hljs-keyword">super</span> 类名 &gt;</code></pre><p>限制：只能接收指定类型及其父类</p></blockquote><h3 id="十六map"><a class="markdownIt-Anchor" href="#十六map"></a> 十六，Map</h3><blockquote><p>Collection 中定义的是单列集合</p><p>Map 中定义的是双列集合，在 Map 中存储元素时，要将键和值形成一一对应的映射关系才能存储到集合中</p><p>Map 的特点：</p><ol><li>Map 中的一个元素包含两个内容（一个是 key 键，另一个是 value 值）</li><li>key 和 value 的数据类型是任意的</li><li>value 是可以重复的</li><li>Map 中 key 和 value 所形成关系称为一一对应的映射关系。</li></ol></blockquote><h4 id="161-hashmap的常用方法"><a class="markdownIt-Anchor" href="#161-hashmap的常用方法"></a> 16.1 HashMap的常用方法</h4><blockquote><ol><li>put(k, v):将 kv 键值对存储到 Map 中，当 key 重复时，返回被替换的 value</li><li>remove(k)：将键所对应的整个键值对删除，返回被删除的 value</li><li>remove(k, v)：判断参数形成的键值对是否在集合中，如果存在，返回 true 并删除</li><li>replace(k, v)：将 v 替换指定 k 上的 值</li><li>replace(k , oldValue , newValue)：判断 k 和 oldValue 形成的键值对是否在集合中，如果存在，用 newValue 替换 k 上的 oldValue</li><li>clear()</li><li>size()</li><li>containsKey(Object o)：判断是否存在指定键</li><li>containsValue(Object o)：判断是否存在指定值</li><li>isEmpty()</li><li>values()：返回 Map 中值组成的 Collection 集合</li></ol></blockquote><h4 id="162-map的遍历"><a class="markdownIt-Anchor" href="#162-map的遍历"></a> 16.2 Map的遍历</h4><blockquote><p>Map 不能使用普通 for 循环，因为 Map 没有下标</p><p>Map 也不能使用增强 for 循环，因为 Map 对象不是 Iterable 实例，如果使用增强 for 循环遍历 Map，会报错。 Can only iterate over an array or an instance of java.lang.Iterable</p></blockquote><blockquote><p>遍历 Map 的方式：</p><p>一，</p><ol><li>通过 Map 的 keySet() 方法，获取 Map 集合中所有 Key 组成的 Set 集合</li><li>遍历该 Set 集合来获取 Map 中的每一个 Key</li><li>通过 Map 的 get(k) 方法获取每一个 Value</li></ol><pre><code class="hljs java">HashMap&lt;String, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();map.put(<span class="hljs-string">&quot;HGFDF&quot;</span>, <span class="hljs-string">&quot;李四&quot;</span>);map.put(<span class="hljs-string">&quot;GFDC&quot;</span>, <span class="hljs-string">&quot;李四&quot;</span>);map.put(<span class="hljs-string">&quot;GFDD&quot;</span>, <span class="hljs-string">&quot;赵云&quot;</span>);map.put(<span class="hljs-string">&quot;GVFDSE&quot;</span>, <span class="hljs-string">&quot;王五&quot;</span>);map.put(<span class="hljs-string">&quot;FFDSA&quot;</span>, <span class="hljs-string">&quot;田七&quot;</span>);Set&lt;String&gt; keys = map.keySet();<span class="hljs-comment">/*for (String k : keys) &#123;</span><span class="hljs-comment">System.out.println(k + &quot;===&quot; + map.get(k));</span><span class="hljs-comment">&#125;*/</span>Iterator&lt;String&gt; it = keys.iterator();<span class="hljs-keyword">while</span>(it.hasNext())&#123;    String key = it.next();    System.out.println(key + <span class="hljs-string">&quot;-&quot;</span>+ map.get(key));&#125;</code></pre><p>二，</p><ol><li><p>通过 Map 的 entrySet() 方法，获取 Map 集合中每个键值对的映射关系组成的 Set 集合</p><p>由于 键和值 形成的是一一对应的映射关系，所以通过映射关系就可以确定当初这个关系是由哪个键和哪个值形成的</p></li><li><p>遍历该 Set 集合来获取 Map 中的每一个映射关系</p></li><li><p>通过映射关系 Entry 对象的 getKey() 和 getValue() 来分别获取键和值</p></li></ol><pre><code class="hljs java">HashMap&lt;String, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();map.put(<span class="hljs-string">&quot;HGFDF&quot;</span>, <span class="hljs-string">&quot;李四&quot;</span>);map.put(<span class="hljs-string">&quot;GFDC&quot;</span>, <span class="hljs-string">&quot;李四&quot;</span>);map.put(<span class="hljs-string">&quot;GFDD&quot;</span>, <span class="hljs-string">&quot;赵云&quot;</span>);map.put(<span class="hljs-string">&quot;GVFDSE&quot;</span>, <span class="hljs-string">&quot;王五&quot;</span>);map.put(<span class="hljs-string">&quot;FFDSA&quot;</span>, <span class="hljs-string">&quot;田七&quot;</span>);Set&lt;Entry&lt;String, String&gt;&gt; set = map.entrySet();<span class="hljs-comment">/*for(Entry&lt;String, String&gt; en : set)&#123;</span><span class="hljs-comment">System.out.println(en.getKey() + &quot;===&quot;+ en.getValue());</span><span class="hljs-comment">&#125;*/</span>Iterator&lt;Entry&lt;String, String&gt;&gt; it = set.iterator();<span class="hljs-keyword">while</span>(it.hasNext())&#123;    Entry&lt;String, String&gt; en = it.next();    System.out.println(en.getKey() + <span class="hljs-string">&quot;===&quot;</span>+ en.getValue());&#125;</code></pre></blockquote><h4 id="163-map-中其他的常见实现类"><a class="markdownIt-Anchor" href="#163-map-中其他的常见实现类"></a> 16.3 Map 中其他的常见实现类</h4><blockquote><ol><li>HashMap：不保证线程同步，速度快，无序的</li><li>LinkedHashMap：有序的 Map</li><li>HashTable：线程安全，速度慢</li><li>TreeMap：根据 key 自动排序，key 的类型必须实现 Comparable 接口</li><li>Properties：key 和 value 都必须 String，主要用于读取配置文件</li></ol></blockquote><h4 id="164-map-中存储自定义类型"><a class="markdownIt-Anchor" href="#164-map-中存储自定义类型"></a> 16.4 Map 中存储自定义类型</h4>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>常用类等</title>
    <link href="/2019/02/12/%E5%B8%B8%E7%94%A8%E7%B1%BB%E7%AD%89/"/>
    <url>/2019/02/12/%E5%B8%B8%E7%94%A8%E7%B1%BB%E7%AD%89/</url>
    
    <content type="html"><![CDATA[<h3 id="一scanner"><a class="markdownIt-Anchor" href="#一scanner"></a> 一，Scanner</h3><blockquote><p>概念：Scanner 是一个专门用于接收键盘输入的类，它在 java.util 包中的</p><p>构造函数：</p><ol><li>new Scanner(<a href="http://System.in">System.in</a>)</li></ol><p>常用功能：</p><ol><li><p>nextInt()</p></li><li><p>nextInt(int radix)：</p><p>举例：nextInt(2)，表示系统会将输入的内容视为二进制数，返回一个对应的十进制数</p></li><li><p>nextDouble()</p></li><li><p>next() 和 String nextLine()：都是用于接收字符串，next()方法会将空白字符视为输入结束</p></li></ol><p>注：如果输入类型与指定类型不匹配会发生 InputMismatchException （输入类型不匹配异常）</p></blockquote><h3 id="二random"><a class="markdownIt-Anchor" href="#二random"></a> 二，Random</h3><blockquote><p>概念：Random 是一个专门用于产生伪随机数的类，它在 java.util包中</p><p>构造函数：</p><ol><li>new Random()</li></ol><p>常用方法：</p><ol><li>nextInt()</li><li>nextInt(int bound)：例如随机[ n， m ]之间的数，nextInt(m - n + 1) + n</li><li>nextDouble()：返回 [ 0.0，1.0 )</li></ol></blockquote><h3 id="三math"><a class="markdownIt-Anchor" href="#三math"></a> 三，Math</h3><blockquote><p>概念：Math是一个用于执行基本数学运算，例如初等函数，对数、三角函数的类，它 java.lang 包中</p><p>注：</p><ol><li>Math类是 final 的</li><li>Math类中的成员变量和成员方法都是静态的</li><li>Math类的构造函数是私有化的</li></ol><p>静态常量：</p><ol><li>E：自然对数的底数</li><li>PI：圆周率</li></ol><p>常用方法：</p><ol><li><p>abs(double n)：求绝对值</p></li><li><p>ceil(double n)：向上取整</p></li><li><p>floor(double n)：向下取整</p></li><li><p>toDegrees(double n)：弧度制转角度值</p></li><li><p>toRadians(double n)：角度值转弧度制</p></li><li><p>sin(double n)</p></li><li><p>pow(double a,double b)：求a的b次方</p></li><li><p>max(double a,double b)</p></li><li><p>min(double a,double b)</p></li><li><p>sqrt(double n)：开根号</p></li><li><p>random()：随机返回 [ 0.0，1.0 )</p></li><li><p>rint(double n)：四舍五入，返回 double</p></li><li><p>round(double n)：四舍五入，返回 int</p><p>注：rint(-3.5) 返回-4.0；round(-3.5)返回 -3</p></li></ol></blockquote><h3 id="四string"><a class="markdownIt-Anchor" href="#四string"></a> 四，String</h3><blockquote><p>概念：String 表示字符串，它 java.lang 包中</p><p>注：</p><ol><li>所有字符串字面值，如：“abc”，都是字符串类的对象</li><li>字符串是常量</li><li>字符串存储在字符串常量池中，是共享的</li><li>== 在比较基本数据类型时，比较的是数据值；在比较引用数据类型时，比较的是地址；在 Object 类中有 equals 方法用来比较两个对象的地址值，在 String 类中对Object的 equals 方法进行了重写，来比较两个字符串的数据值是否相同</li></ol><p>构造函数：</p><ol><li>new String()：创建一个空的字符串</li><li>new String(byte[] bytes)：将字节数组中的元素根据ASCII码表转换成字符后生成字符串</li><li>new String(char[] chars)：将字符数组中的元素拼接成一个字符串</li><li>new String(String s)</li><li>new String(byte[] bytes, Charset charset)：可以根据指定的字符集编码生成字节数组所对应的字符串</li><li>new String(byte[] bytes , int offset , int length)：从字节数组的指定位置开始获取指定数量的元素拼接成字符串</li><li>new String(char[] chars , int offset , int count)：从字符数组的指定位置开始获取指定数量的元素拼接成字符串</li></ol><p>常用方法：</p><ol><li>charAt(int index)：根据下标返回字符</li><li>indexOf(String str)：根据字符串内容返回所在下标</li><li>indexOf(String str，int index)：从指定位置开始查找指定字符串所在的下标</li><li>lastIndeOf(String str)：返回最后一个字符串内容所在的下标</li><li>lastIndexOf(String str, int index)：从指定位置开始，从后往前查找最后一个字符串所在的下标</li><li>compareTo(String str)：根据字典顺序比较字符的大小，返回差值</li><li>compareToIgnoreCase(String str)：忽略大小写比较</li><li>equals(String str)：比较字符串的内容，返回布尔值</li><li>equalsIgnoreCase(String str)：忽略大小写比较字符串内容</li><li>contains(String str)：判断字符串是否包含子串</li><li>codePointAt(int index)：通过下标返回字符的十进制数</li><li>concat(String str)：拼接字符串</li><li>endsWith(String str)：判断是否以指定字符串结尾</li><li>startsWith(String str)：判断是否以指定字符串开头</li><li>getBytes()：获取字符串的字节数组</li><li>toCharArray()：获取字符串的字符数组</li><li>isEmpty()：判断字符串的内容是否为空</li><li>length()：返回字符串的长度</li><li>replace(String oldStr, String newStr)：将新字符串替换原始字符串</li><li>substring(int index)：从指定位置截取到字符串末尾</li><li>subString(int beginIndex, int endIndex)：从begin下标截取到end下标，不包含end</li><li>toLowerCase()：将大写字母转换成小写字母</li><li>toUpperCase()：将小写字母转换成大写字母</li><li>trim()：去除字符串两端的空格</li></ol></blockquote><blockquote><p>正则表达式</p><p>概念：正则表达式是一种特殊的用来对其他字符串进行匹配、切割、替换、查找的规则，正则表达式本身也是一个字符串。</p><p>功能：</p><ol><li>匹配：字符串.matches(规则)</li></ol><pre><code class="hljs java"><span class="hljs-comment">// 匹配手机号，1开头，纯数字，11位</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(String tel)</span></span>&#123;    String regex = <span class="hljs-string">&quot;1\\d&#123;10&#125;&quot;</span>;    System.out.println(tel.matches(regex));&#125;<span class="hljs-comment">// 匹配邮箱，前1~3位是字母，4~8位是数字，@,数字字母下划线2~7位，.com结尾</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f2</span><span class="hljs-params">(String email)</span></span>&#123;    String regex = <span class="hljs-string">&quot;[a-zA-Z]&#123;1,3&#125;[0-9]&#123;4,8&#125;@\\w&#123;2,7&#125;[.]com&quot;</span>;    System.out.println(email.matches(regex));&#125;</code></pre><ol start="2"><li>切割：字符串.split(规则)，返回 String 数组</li></ol><pre><code class="hljs java"><span class="hljs-comment">// 获取IP地址中的每一段</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(String ip)</span></span>&#123;    String regex = <span class="hljs-string">&quot;\\.&quot;</span>;    String str[] = ip.split(regex);    System.out.println(Arrays.toString(str));    System.out.println(str.length);&#125;</code></pre><ol start="3"><li>替换：字符串.replaceAll(规则，新值)</li></ol><pre><code class="hljs java"><span class="hljs-comment">// 用*替换字符串中的所有“天”</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(String msg)</span></span>&#123;    String regex = <span class="hljs-string">&quot;天+&quot;</span>;    msg = msg.replaceAll(regex, <span class="hljs-string">&quot;*&quot;</span>);    System.out.println(msg);&#125;<span class="hljs-comment">// 叠词替换</span><span class="hljs-comment">// 帮别人改掉口吃的毛病“我我我我是是是是是好人人人”-&gt;“我是好人”</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span></span>&#123;    String s = <span class="hljs-string">&quot;我我我我是是是是是好人人人&quot;</span>;    s = s.replaceAll(<span class="hljs-string">&quot;(.)\\1+&quot;</span>, <span class="hljs-string">&quot;$1&quot;</span>);    System.out.println(s);&#125;</code></pre><ol start="4"><li>查找</li></ol><pre><code class="hljs java"><span class="hljs-comment">// 查找字符串中3个字母组成的单词</span>Pattern p = Pattern.compile(<span class="hljs-string">&quot;\\b[a-zA-Z]&#123;3&#125;\\b&quot;</span>);Matcher m = p.matcher(<span class="hljs-string">&quot;You are a student!!!&quot;</span>);<span class="hljs-keyword">while</span>(m.find())&#123;<span class="hljs-comment">// find()：判断是否有下一个符合正则的子字符串</span>    System.out.println(m.group());<span class="hljs-comment">// group()：获取符合规则的下一个子字符串</span>&#125;</code></pre><pre><code class="hljs inform7">字符类 <span class="hljs-comment">[abc]</span> a、b 或 c（简单类） <span class="hljs-comment">[^abc]</span> 任何字符，除了 a、b 或 c（否定） <span class="hljs-comment">[a-zA-Z]</span> a 到 z 或 A 到 Z，两头的字母包括在内（范围） <span class="hljs-comment">[a-d<span class="hljs-comment">[m-p]</span>]</span> a 到 d 或 m 到 p：<span class="hljs-comment">[a-dm-p]</span>（并集） <span class="hljs-comment">[a-z&amp;&amp;<span class="hljs-comment">[def]</span>]</span> d、e 或 f（交集） <span class="hljs-comment">[a-z&amp;&amp;<span class="hljs-comment">[^bc]</span>]</span> a 到 z，除了 b 和 c：<span class="hljs-comment">[ad-z]</span>（减去） <span class="hljs-comment">[a-z&amp;&amp;<span class="hljs-comment">[^m-p]</span>]</span> a 到 z，而非 m 到 p：<span class="hljs-comment">[a-lq-z]</span>（减去）   预定义字符类 . 任何字符（与行结束符可能匹配也可能不匹配） \d 数字：<span class="hljs-comment">[0-9]</span> \D 非数字： <span class="hljs-comment">[^0-9]</span> \s 空白字符：<span class="hljs-comment">[\t\n\x0B\f\r]</span> \S 非空白字符：<span class="hljs-comment">[^\s]</span> \w 单词字符：<span class="hljs-comment">[a-zA-Z_0-9]</span> \W 非单词字符：<span class="hljs-comment">[^\w]</span> Greedy 数量词 X? X，一次或一次也没有 X* X，零次或多次 X+ X，一次或多次 X&#123;n&#125; X，恰好 n 次 X&#123;n,&#125; X，至少 n 次 X&#123;n,m&#125; X，至少 n 次，但是不超过 m 次 </code></pre></blockquote><h3 id="五stringbuilder和stringbuffer"><a class="markdownIt-Anchor" href="#五stringbuilder和stringbuffer"></a> 五，StringBuilder和StringBuffer</h3><blockquote><p>为什么要使用StringBuilder、StringBuffer？</p><p>原因：</p><ol><li>String 是不可变的，StringBuilder 和 StringBuffer称为字符串缓冲区，它们是可变的</li><li>String 占用资源多</li></ol><p>以 StringBuffer 为例：</p><p>概念：StringBuffer 是可变的字符序列，StringBuffer 是字符串缓冲区，它 java.lang 包中</p><p>构造函数：</p><ol><li>new StringBuffer()：构造一个其中不带字符的字符串缓冲区，初始容量为 16 个字符。</li><li>new StringBuffer(int capacity)：构造一个不带字符，但具有指定初始容量的字符串缓冲区。</li><li>new StringBuffer(String str)：构造一个字符串缓冲区，并将其内容初始化为指定的字符串内容。</li></ol><p>常用方法：</p><ol><li>append(Object obj)</li><li>delete(int start, int end)</li><li>deleteCharAt(int index)</li><li>insert(int index, Object obj)</li><li>reverse()</li><li>setCharAt(int index, Char c)</li></ol><p>StringBuffer 和 StringBuilder 的区别：</p><ol><li>StringBuffer 线程安全，StringBuilder 不保证线程同步</li><li>StringBuilder 比 StringBuffer 更快</li></ol><p>StringBuffer 和 StringBuilder 与 String 的转换：</p><ol><li>StringBuffer / StringBuilder  -&gt; String</li></ol><pre><code class="hljs java"><span class="hljs-comment">// 使用 toString</span>StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer(<span class="hljs-string">&quot;abc123&quot;</span>);String s = sb.toString();<span class="hljs-comment">// 使用 String 的构造函数</span>StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer(<span class="hljs-string">&quot;abc123&quot;</span>);String s = <span class="hljs-keyword">new</span> String(sb);</code></pre><ol start="2"><li>String -&gt; StringBuffer / StringBuilder</li></ol><pre><code class="hljs java"><span class="hljs-comment">// 需要使用 StringBuffer / StringBuilder 的构造函数进行转换</span>String s = <span class="hljs-string">&quot;abc&quot;</span>;StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder(s);</code></pre></blockquote><h3 id="六date"><a class="markdownIt-Anchor" href="#六date"></a> 六，Date</h3><blockquote><p>概念：类 Date 表示特定的瞬间，精确到毫秒。 它 java.util 包中</p><p>作用：</p><ol><li>通过 Date 对象，获取对应的年、月、日、时、分、秒等时间字段</li><li>将 Date 对象格式化成标准的日期字符串</li><li>将格式化后的日期字符串进行解析，转换成 Date 对象</li></ol><p>构造函数：</p><ol><li>new Date()</li><li>new Date(long date)</li><li>new Date (int year,  int month, int date, int hrs, int min, int sec)：已过期</li></ol><p>常用方法：</p><ol><li>getXxx()：获取指定的时间字段</li><li>setXxx()：设置指定的时间字段</li><li>a . after (Date b)：判断日期 a 是否在日期 b 之后</li><li>a . before (Date b)：判断日期 a 是否在日期 b 之前</li><li>getTime()：功能同 System.currentTimeMillis()；</li></ol></blockquote><h3 id="七simpledateformat"><a class="markdownIt-Anchor" href="#七simpledateformat"></a> 七，SimpleDateFormat</h3><blockquote><p>概念：SimpleDateFormat 是一个以与语言环境有关的方式来格式化和解析日期的具体类。它允许进行格式化（日期 -&gt;  文本）、解析（文本 -&gt; 日期）和规范化。  它 java.text 包中</p><p>功能：</p><ol><li>格式化（Date对象 -&gt; String）</li></ol><pre><code class="hljs java">SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy年MM月dd日 HH时mm分ss秒&quot;</span>);String time = sdf.format(<span class="hljs-keyword">new</span> Date(System.currentTimeMillis() - <span class="hljs-number">3600</span> * <span class="hljs-number">16</span> * <span class="hljs-number">1000</span>));System.out.println(time);</code></pre><ol start="2"><li>解析（String -&gt; Date对象）</li></ol><pre><code class="hljs java">SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);String time = <span class="hljs-string">&quot;2020-07-09 22:12:51&quot;</span>;Date d = sdf.parse(time);System.out.println(d);</code></pre></blockquote><h3 id="八calendar"><a class="markdownIt-Anchor" href="#八calendar"></a> 八，Calendar</h3><blockquote><p>概念：Calendar 类是一个抽象类，它提供了一些与日期时间字段进行转换的方法，它 java.util 包中</p><p>Calendar 提供了一个静态方法  getInstance，以获得此类型的一个通用的对象。Calendar 的  getInstance 方法返回一个 Calendar 对象，其日历字段已由当前日期和时间初始化。</p><p>对象的获取：</p><ol><li>Calendar.getInstance()</li></ol><p>常用方法：</p><ol><li><p>get(int field)：返回指定日历字段的值</p></li><li><p>set(int field，int value)：将指定的日历字段设置为给定的值</p></li><li><p>set(int year，int month，int date ，int hour，int minute，int second)</p></li><li><p>add(int field，int value)：为指定的日历字段设置添加或者减去指定的时间</p><p>value：</p><p>​正数：添加</p><p>​负数：减少</p></li><li><p>getTime()：返回一个 Date 对象</p></li><li><p>getTimeInMillis()：功能同 Date 的 getTime() 和 System.currentTimeMillis()；</p></li></ol></blockquote><h3 id="九object"><a class="markdownIt-Anchor" href="#九object"></a> 九，Object</h3><blockquote><p>概念：类 Object 是类层次结构的根类。每个类都使用 Object 作为超类。所有对象（包括数组）都实现这个类的方法。</p><p>常用方法：</p><ol><li><p>toString()</p><p>打印对象时，会调用父类中的 toString() 方法输出地址，没有意义；</p><p>需要对父类的 toString() 方法进行重写；</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student [name=&quot;</span> + name + <span class="hljs-string">&quot;, age=&quot;</span> + age + <span class="hljs-string">&quot;]&quot;</span>;&#125;</code></pre></li><li><p>equals()</p><p>重写 equals() 方法可以比较两个对象的属性是否相等</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span> </span>&#123;    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span> == obj)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-keyword">if</span>(obj == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-keyword">if</span>(!(obj <span class="hljs-keyword">instanceof</span> Student))&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    Student s = (Student)obj;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name.equals(s.name) &amp;&amp; <span class="hljs-keyword">this</span>.age == s.age;&#125;</code></pre><p>补充：</p><p>Objects中的静态方法equals</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object a, Object b)</span> </span>&#123;<span class="hljs-keyword">return</span> (a == b) || (a != <span class="hljs-keyword">null</span> &amp;&amp; a.equals(b));&#125;<span class="hljs-comment">// 该方法可以避免空指针异常</span></code></pre></li></ol></blockquote><h3 id="十arrays"><a class="markdownIt-Anchor" href="#十arrays"></a> 十，Arrays</h3><blockquote><p>概念：此类包含用来操作数组（比如排序和搜索）的各种方法。它 java.util 包中</p><p>常用方法：</p><ol><li><p>toString(数组)</p></li><li><p>binarySearch(数组，value)：使用二分搜索法，在数组中查询指定元素的位置，</p><p>前提：1. 必须是升序排列的 2.不能有重复元素</p></li><li><p>sort(数组)：升序排列</p></li><li><p>copyOf(数组，长度)</p></li><li><p>asList(T…a)：将可变参数中的元素封装成一个 List 集合</p></li><li><p>fill(数组，value)：使用 value 值赋值给指定数组的每个元素</p></li></ol></blockquote><h3 id="十一system"><a class="markdownIt-Anchor" href="#十一system"></a> 十一，System</h3><blockquote><p>概念：System 类包含一些有用的类字段和方法。它不能被实例化。它 java.lang 包中</p><p>字段摘要：</p><ol><li>in</li></ol><pre><code class="hljs java">Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);BufferedReader br = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(System.in));</code></pre><ol start="2"><li>out</li></ol><pre><code class="hljs java">System.out.println();</code></pre><ol start="3"><li>err：“标准”错误输出流</li></ol><pre><code class="hljs java">System.err.println();</code></pre><p>常用方法：</p><ol><li>System.currentTimeMillis()</li><li>System.arrayCopy(Object src , int srcPos , Object dest , int destPos , int length)</li><li>System.exit(0)：结束 JVM , 参数：0 表示正常关闭，非0 表示异常关闭</li><li>System.gc()：运行垃圾回收器</li></ol></blockquote><h3 id="十二包装类"><a class="markdownIt-Anchor" href="#十二包装类"></a> 十二，包装类</h3><h4 id="121-概念"><a class="markdownIt-Anchor" href="#121-概念"></a> 12.1 概念</h4><blockquote><p>概念：Java 的数据类型分为基本数据类型和引用数据类型，使用基本数据类型的原因主要是效率高；但是因为基本数据类型没有对象，所以不能对属性和方法进行调用。因此如果我们想要使用基本数据类型进行属性和方法的调用就需要使用到它们对应的包装类。</p><p>综上：包装类就是基本数据类型对应的引用数据类型</p><p>基本数据类型包装类</p><p>byteByte</p><p>short  Short</p><p>intInteger</p><p>longLong</p><p>floatFloat</p><p>double                          Double</p><p>charCharacter</p><p>boolean Boolean</p></blockquote><h4 id="122-包装类对象的创建"><a class="markdownIt-Anchor" href="#122-包装类对象的创建"></a> 12.2 包装类对象的创建</h4><blockquote><p>格式：</p><ol><li><p>Integer i = new Integer(int)；</p></li><li><p>Integer j = new Integer(String)；</p></li></ol><p>注：如果参数不是整数形式的字符串会发生 NumberFormatException（数字格式异常）</p></blockquote><h4 id="123-成员的变量和成员方法"><a class="markdownIt-Anchor" href="#123-成员的变量和成员方法"></a> 12.3 成员的变量和成员方法</h4><blockquote><ol><li>static MAX_VALUE</li><li>static MIN_VALUE</li><li>static max(int a, int b)</li><li>static min(int a, int b)</li><li>static compare(int a, int b)：返回 0：表示相同，1：表示 a &gt; b ，-1：表示 a &lt; b</li><li>static toBinaryString(int i )</li><li>static toOctalString(int i)</li><li>static toHexString(int i )</li></ol></blockquote><h4 id="124-装箱和拆箱"><a class="markdownIt-Anchor" href="#124-装箱和拆箱"></a> 12.4 装箱和拆箱</h4><blockquote><p>概念：基本类型和对应包装类之间的转换就是装箱和拆箱</p><p>装箱：将基本数据类型转换成对应的包装类（基本 --&gt; 包装）</p><ol><li>构造函数：<ol><li>new Integer(int i)</li></ol></li><li>静态方法：<ol><li>valueOf(int i)</li></ol></li></ol><p>拆箱：将包装类转换成对应的基本数据类型（包装 --&gt; 基本）</p><ol><li>成员方法：<ol><li>intValue()</li></ol></li></ol><p>从 jdk 1.5 开始提供了自动装拆箱：装箱和拆箱的动作自动完成（直接赋值）</p><p>自动拆箱：</p><pre><code class="hljs java">&gt;<span class="hljs-keyword">int</span> t1 = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">7</span>);</code></pre><p>自动装箱：</p><pre><code class="hljs java">&gt;Integer t2 = <span class="hljs-number">6</span>;</code></pre><p>补充：jdk 9 开始包装类中的构造函数都变成了过期函数，因为系统不再推荐使用构造函数来创建包装类的对象，系统推荐以自动装箱的方法来创建</p></blockquote><h4 id="125-基本类型与字符串类型的转换"><a class="markdownIt-Anchor" href="#125-基本类型与字符串类型的转换"></a> 12.5 基本类型与字符串类型的转换</h4><blockquote><p>基本类型/包装类 --&gt; 字符串：</p><ol><li>拼接空字符串（最常用）</li><li>使用包装类中的静态方法 toString(参数)</li><li>使用包装类中的成员方法 toString()</li><li>使用 String 类中的静态方法 valueOf(参数)</li></ol><p>字符串 --&gt; 基本类型/包装类</p><ol><li><p>使用包装类的构造函数（不推荐）</p></li><li><p>使用包装类的静态 parseXxx(String str) 方法</p></li><li><p>使用包装类的静态 valueOf(String str) 方法</p><p>注：parseXxx(String str) 和 valueOf(String str) 方法可能会发生NumberFormatException（数字格式异常）</p></li></ol></blockquote><h3 id="十三异常"><a class="markdownIt-Anchor" href="#十三异常"></a> 十三，异常</h3><h4 id="131-概念"><a class="markdownIt-Anchor" href="#131-概念"></a> 13.1 概念</h4><blockquote><p>概念：在程序中的发生的不正常的情况，系统将其封装成了类，就是异常类，当运行到有异常的代码时，程序会终止。</p></blockquote><h4 id="132-异常的体系"><a class="markdownIt-Anchor" href="#132-异常的体系"></a> 13.2 异常的体系</h4><blockquote><p>Throwable：它是错误或异常的超类。</p><p>​– Exception 异常：可以避免的异常问题，或者可以通过抛出或者捕获来解决</p><p>​– Error 错误：不能处理，只能尽可能避免的错误</p></blockquote><h4 id="133-异常的原理"><a class="markdownIt-Anchor" href="#133-异常的原理"></a> 13.3 异常的原理</h4><h4 id="134-异常的处理"><a class="markdownIt-Anchor" href="#134-异常的处理"></a> 13.4 异常的处理</h4><blockquote><p>方式一：使用 throws 关键字将异常抛给调用者</p><p>作用：当方法内部发生了异常后，可以通过 throws 将异常对象抛给调用者，让调用者来决定是进行捕获还是继续抛出，如果在不断抛出的过程中，有了捕获动作，那么异常就由捕获进行了处理，不再将异常对象抛给 JVM。</p><p>问：使用抛出的方式将异常抛给了调用者，并没有实质上的对异常进行处理，那它的意义是什么？</p><p>答：在方法的声明上告知了调用者当前方法会发生何种异常，那么不同的调用者就可以根据具体情况对异常进行不同的处理。</p><p>注：</p><ol><li>throws 关键字必须写在方法的声明位置</li><li>throws 关键字后必须跟上发生的异常类型或者Exception</li><li>如果抛出的是 RuntimeException 及其子类，那么调用者可以不进行异常的处理；</li><li>如果抛出的不是 RuntimeException 及其子类，那么调用者必须对异常进行处理（继续抛出，捕获）</li><li>如果方法中出现了多个异常时，在方法声明处也可以抛出多个异常</li></ol></blockquote><blockquote><p>方式二：使用 try-catch 代码块对异常进行捕获</p><p>格式：</p><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;    <span class="hljs-comment">// 可能发生异常的代码（需要进行异常检测的代码）</span>&#125;<span class="hljs-keyword">catch</span>(当 <span class="hljs-keyword">try</span> 中发生异常后创建的异常类对象)&#123;    <span class="hljs-comment">// 当 try 中发生异常时，会立即进入 catch ，由 catch 代码块对异常进行处理</span>&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;    &#125;<span class="hljs-keyword">catch</span>()&#123;    &#125;<span class="hljs-keyword">finally</span>&#123;    <span class="hljs-comment">// finally 中的代码一定会执行，一般在 finally 中执行释放资源的动作</span>&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;    &#125;<span class="hljs-keyword">finally</span>&#123;    &#125;</code></pre><p>注：</p><ol><li>try 代码块用于检测可能发生异常的代码</li><li>catch 代码块中的代码在 try 代码块没有发生异常时不会执行；try 中出现异常时，会立即进入 catch 处理异常</li><li>catch 后 &quot;()&quot;中的异常类对象必须是所发生的异常类对象或者它的父类对象</li><li>finally 中的代码一定会执行，一般用来释放资源</li><li>try 、 catch、 finally 都不能单独使用</li><li>try 或者 catch 中有 return 语句，finally 中的代码仍然会执行；如果 finally 中 return，那么无论方法是否有异常都会返回 finally 中的 return</li></ol></blockquote><h4 id="135-try-catch-处理多个异常的情况"><a class="markdownIt-Anchor" href="#135-try-catch-处理多个异常的情况"></a> 13.5 try-catch 处理多个异常的情况</h4><blockquote><ol><li><p>多个异常一次处理</p><p>try 中发生异常时，直接创建 Exception 对象进行异常的处理</p><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;    <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;    Random r = <span class="hljs-keyword">new</span> Random();    <span class="hljs-keyword">int</span> index = r.nextInt(<span class="hljs-number">5</span>);    System.out.println(<span class="hljs-number">10</span> / arr[index]);&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;    System.out.println(<span class="hljs-string">&quot;错了&quot;</span>);&#125;</code></pre></li><li><p>多个异常分别处理</p><p>在 try 后，使用多个 catch 代码块，针对程序出现的各种异常进行单独的捕获</p><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;    <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;    Random r = <span class="hljs-keyword">new</span> Random();    <span class="hljs-keyword">int</span> index = r.nextInt(<span class="hljs-number">5</span>);    System.out.println(<span class="hljs-number">10</span> / arr[index]);&#125; <span class="hljs-keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;    System.out.println(<span class="hljs-string">&quot;越界了&quot;</span>);&#125; <span class="hljs-keyword">catch</span> (ArithmeticException e) &#123;    System.out.println(<span class="hljs-string">&quot;除零了&quot;</span>);&#125;</code></pre></li><li><p>处理未知异常</p><p>如果 catch 没有考虑到所有可能发生的异常，那么仍然可能会有未知的异常方法，此时我们可以在多个 catch 的最后使用 Exception 进行未知异常的捕获。</p><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;    <span class="hljs-keyword">int</span>[] arr = array;    Random r = <span class="hljs-keyword">new</span> Random();    <span class="hljs-keyword">int</span> index = r.nextInt(<span class="hljs-number">5</span>);    System.out.println(<span class="hljs-number">10</span> / arr[index]);&#125; <span class="hljs-keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;    System.out.println(<span class="hljs-string">&quot;越界了&quot;</span>);&#125; <span class="hljs-keyword">catch</span> (ArithmeticException e) &#123;    System.out.println(<span class="hljs-string">&quot;除零了&quot;</span>);&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;    System.out.println(<span class="hljs-string">&quot;未知异常&quot;</span>);&#125;</code></pre><p>注：范围大的异常必须在范围小的异常之后</p></li></ol></blockquote><h4 id="136-异常的方法"><a class="markdownIt-Anchor" href="#136-异常的方法"></a> 13.6 异常的方法</h4><blockquote><ol><li>toString()：返回异常类</li><li>getMessage()：返回异常的原因</li><li>e.printStackTrace()：输出发生异常的类，异常的原因和异常的位置</li></ol></blockquote><h4 id="137-自定义异常类"><a class="markdownIt-Anchor" href="#137-自定义异常类"></a> 13.7 自定义异常类</h4><blockquote><p>概念：Java 中所提供的异常类不够使用时，我们可以进行自定义</p><p>步骤：</p><ol><li>创建自定义异常类继承 Exception</li><li>在自定义异常类中添加构造函数和重载的构造函数</li><li>在满足发生异常条件的情况下，需要创建出自定义异常类的对象，并使用 throw 关键字抛出</li></ol></blockquote><h3 id="十四单例设计模式"><a class="markdownIt-Anchor" href="#十四单例设计模式"></a> 十四，单例设计模式</h3><blockquote><p>设计模式的概念：解决开发中某些特定问题时的固定写法</p><p>单例：单个实例，整个应用有且只有一个该类的对象</p><p>步骤：</p><ol><li>构造函数私有化</li><li>在本类中创建本类对象</li><li>在本类中对外提供一个可以返回本类对象的方法</li></ol></blockquote><h4 id="141-饿汉式"><a class="markdownIt-Anchor" href="#141-饿汉式"></a> 14.1 饿汉式</h4><blockquote><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton1</span></span>&#123;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton1</span><span class="hljs-params">()</span></span>&#123;&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton1 s = <span class="hljs-keyword">new</span> Singleton1();<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton1 <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> s;&#125;&#125;</code></pre></blockquote><h4 id="142-懒汉式"><a class="markdownIt-Anchor" href="#142-懒汉式"></a> 14.2 懒汉式</h4><blockquote><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton2</span></span>&#123;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton2</span><span class="hljs-params">()</span></span>&#123;&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton2 s = <span class="hljs-keyword">null</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton2 <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">if</span>(s == <span class="hljs-keyword">null</span>)&#123;s = <span class="hljs-keyword">new</span> Singleton2();&#125;<span class="hljs-keyword">return</span> s;&#125;&#125;</code></pre></blockquote><h4 id="143-懒汉式与饿汉式的区别"><a class="markdownIt-Anchor" href="#143-懒汉式与饿汉式的区别"></a> 14.3 懒汉式与饿汉式的区别</h4><blockquote><ol><li>对象创建的时机不同，饿汉式在类加载时，对象已经创建；懒汉式只有 getInstance() 方法被调用时才会创建，饿汉式的加载效率比懒汉式高。</li><li>由于饿汉式中创建的对象在类加载时就已经存在，所以该对象没有被访问也会占用内存</li><li>懒汉式线程不安全</li></ol></blockquote><h4 id="144-线程安全的懒汉式"><a class="markdownIt-Anchor" href="#144-线程安全的懒汉式"></a> 14.4 线程安全的懒汉式</h4><blockquote><p>双重检查的单例模式   线程安全</p></blockquote><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton instance = <span class="hljs-keyword">null</span>;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>)&#123;<span class="hljs-keyword">synchronized</span> (Singleton.class)&#123;                <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>)&#123;                    instance = <span class="hljs-keyword">new</span> Singleton();                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> instance;    &#125;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>接口</title>
    <link href="/2019/02/11/%E6%8E%A5%E5%8F%A3/"/>
    <url>/2019/02/11/%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h3 id="一接口的概念"><a class="markdownIt-Anchor" href="#一接口的概念"></a> 一，接口的概念</h3><blockquote><p>概念：接口就是多个类的公共规范，接口是一种引用数据类型，它的本质是一个类，接口是一个特殊的类</p><p>接口的作用：</p><ol><li>对外提供了标准、规范</li><li>扩展了功能</li></ol></blockquote><h3 id="二接口的定义"><a class="markdownIt-Anchor" href="#二接口的定义"></a> 二，接口的定义</h3><blockquote><p>关键字：interface</p><p>格式：</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> 接口名</span>&#123;&#125;</code></pre><p>编写接口的文件是 .java 文件</p><p>接口在编译后生成的仍然是 .class 的二进制字节码文件</p></blockquote><h4 id="21-接口中成员变量的定义"><a class="markdownIt-Anchor" href="#21-接口中成员变量的定义"></a> 2.1 接口中成员变量的定义</h4><blockquote><p>接口中的成员变量都是静态常量，默认被 public static final 修饰</p></blockquote><h4 id="22-接口中成员方法的定义"><a class="markdownIt-Anchor" href="#22-接口中成员方法的定义"></a> 2.2 接口中成员方法的定义</h4><blockquote><p>接口中的成员方法都是默认被 public abstract 修饰</p></blockquote><h3 id="三接口的使用"><a class="markdownIt-Anchor" href="#三接口的使用"></a> 三，接口的使用</h3><blockquote><p>步骤：</p><ol><li><p>接口中的所有方法都是抽象方法，所以接口也不能创建对象，因此必须有一个 “实现类” 来 “实现”该接口。</p><p>格式：关键字：implements</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> 实现类 <span class="hljs-title">implemnents</span> 接口</span>&#123;    &#125;</code></pre><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;&#125;<span class="hljs-comment">// 子类B 继承了 父类A</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span></span>&#123;&#125;<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">C</span></span>&#123;&#125;<span class="hljs-comment">// 实现类D 实现了 接口C</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">C</span></span>&#123;&#125;</code></pre></li><li><p>重写所有抽象方法</p></li><li><p>创建实现类对象，进行调用</p></li></ol></blockquote><h3 id="四接口的新特性"><a class="markdownIt-Anchor" href="#四接口的新特性"></a> 四，接口的新特性</h3><blockquote><p>从 Java8 开始，接口中允许定义普通（默认）方法</p><p>格式：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">default</span> 返回类型 方法名(参数)&#123;&#125;</code></pre><p>意义：为了解决接口中的功能升级问题</p><p>注：</p><ol><li>接口中的抽象方法必须重写</li><li>接口中的普通（默认）方法也可以重写，重写时，不需要加上 default ，因为 default 关键字在定义方法时是专门给接口中的普通（默认）方法使用的</li></ol></blockquote><blockquote><p>从 Java8 开始，接口中允许定义静态方法</p><p>格式：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> 返回类型 方法名(参数)&#123;&#125;</code></pre><p>注：</p><ol><li>定义方式与普通类中的静态方法一致</li><li>接口中的静态方法只有由接口进行调用，不能由实现类的类名或者实现类的对象进行调用</li></ol></blockquote><blockquote><p>从 Java9 开始，接口中允许定义私有方法</p><p>格式：</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> 返回类型 方法名(参数)&#123;&#125;</code></pre><p>作用：不需要对外暴露，目的是为接口中的普通（默认）方法提供功能上的支持</p></blockquote><h3 id="五类与接口的关系"><a class="markdownIt-Anchor" href="#五类与接口的关系"></a> 五，类与接口的关系</h3><h4 id="51-类与类的关系"><a class="markdownIt-Anchor" href="#51-类与类的关系"></a> 5.1 类与类的关系</h4><blockquote><p>类与类之间的关系是继承：子类继承父类</p><p>格式：</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> 子类 <span class="hljs-keyword">extends</span> 父类</span>&#123;&#125;</code></pre><p>注：类与类之间只能单继承</p></blockquote><h4 id="52-类与接口的关系"><a class="markdownIt-Anchor" href="#52-类与接口的关系"></a> 5.2 类与接口的关系</h4><blockquote><p>类与接口之间的关系是实现：实现类实现接口</p><p>格式：</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> 实现类 <span class="hljs-keyword">implements</span> 接口<span class="hljs-title">A</span>,接口<span class="hljs-title">B</span>,...</span>&#123;&#125;</code></pre><p>注：一个类可以同时实现多个接口（多实现）</p><ol><li>实现类实现多个接口后要重写所有接口中的抽象方法</li><li>多个接口中如果出现了同名抽象方法，实现类只需要实现一次</li><li>如果多个接口中出现了同名的 default 方法，那么实现类必须进行重写</li><li>如果一个父接口中的 default 方法和另一个父接口中的抽象方法同名，那么实现类必须进行重写</li></ol></blockquote><h4 id="53-接口与接口的关系"><a class="markdownIt-Anchor" href="#53-接口与接口的关系"></a> 5.3 接口与接口的关系</h4><blockquote><p>接口与接口之间的关系是继承：子接口继承父接口</p><p>接口之间存在多继承</p><p>格式：</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">A</span></span>&#123;&#125;<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">B</span> </span>&#123;&#125;<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span>,<span class="hljs-title">B</span></span>&#123;&#125;</code></pre><p>注：</p><ol><li>多个父接口中出现了同名的抽象方法和 default 方法时，子接口必须进行重写</li></ol></blockquote><h4 id="54-类在继承类的同时实现接口"><a class="markdownIt-Anchor" href="#54-类在继承类的同时实现接口"></a> 5.4 类在继承类的同时实现接口</h4><blockquote><p>格式：</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> 类名 <span class="hljs-keyword">extends</span> 父类 <span class="hljs-keyword">implements</span> 接口</span>&#123;&#125;</code></pre><p>注：</p><ol><li>父类和接口中出现了同名方法时，优先调用父类的。</li><li>普通父类中的方法（或者抽象类中的非抽象方法）和接口中的抽象方法产生同名冲突时，子类可以不重写，因为从父类中继承下来的方法就相当于对接口中的抽象方法进行了重写。</li></ol></blockquote><h3 id="六接口和抽象类的异同"><a class="markdownIt-Anchor" href="#六接口和抽象类的异同"></a> 六，接口和抽象类的异同</h3><blockquote><p>同：</p><ol><li>抽象类和接口都不能创建对象</li><li>抽象类和接口中都可以定义抽象方法</li><li>抽象类和接口都需要被继承或者实现，通过子类或者实现类重写抽象方法</li></ol><p>异：</p><ol><li><p>抽象类需要被子类继承（extends），接口需要被实现类实现（implements）</p></li><li><p>抽象类中可以有非抽象方法，静态方法，私有方法，但是接口中的方法不能定义非抽象方法、静态方法、私有方法</p><p>注：</p><p>从 Java8 开始，接口中可以通过 default 定义非抽象方法，也可以定义静态方法</p><p>从 Java9 开始，接口中也可以定义私有方法</p></li><li><p>接口中的成员变量都是静态常量，抽象类的成员变量可以是普通变量</p></li><li><p>抽象类中可以有构造方法，接口中没有构造方法</p></li><li><p>抽象类抽取封装的是子类的共性成员，而接口是功能的封装，接口是方法的集合</p></li><li><p>接口的抽象级别比抽象类更高</p></li><li><p>接口中不能有静态代码块，抽象类中可以有</p></li></ol></blockquote><h3 id="七使用匿名内部类创建接口实现类的对象"><a class="markdownIt-Anchor" href="#七使用匿名内部类创建接口实现类的对象"></a> 七，使用匿名内部类创建接口实现类的对象</h3><blockquote><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Net</span></span>&#123;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">check</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">connect</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-keyword">new</span> Net()&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">check</span><span class="hljs-params">()</span></span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">connect</span><span class="hljs-params">()</span></span>&#123;&#125;&#125;;</code></pre></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>内部类</title>
    <link href="/2019/02/11/%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <url>/2019/02/11/%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h3 id="一内部类"><a class="markdownIt-Anchor" href="#一内部类"></a> 一，内部类</h3><h4 id="11-概念"><a class="markdownIt-Anchor" href="#11-概念"></a> 1.1 概念</h4><blockquote><p>概念：将一个类定义在另一个类的内部</p><p>例如：人体和器官的关系，汽车和发动机的关系</p><p>注：内部类在编译后也会生成对应的字节码文件</p><ol><li><p>成员内部类和静态内部类：外部类名$内部类名.class</p></li><li><p>局部内部类：外部类名$序号内部类名.class</p></li><li><p>匿名内部类：Test$序号.class</p><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span>&#123;<span class="hljs-keyword">new</span> T()&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>)</span>&#123;&#125;&#125;;&#125;&#125;<span class="hljs-keyword">interface</span> <span class="hljs-title">T</span>&#123;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>)</span>;&#125;</code></pre></li></ol></blockquote><h4 id="12-分类"><a class="markdownIt-Anchor" href="#12-分类"></a> 1.2 分类</h4><blockquote><ol><li>成员内部类</li><li>静态内部类</li><li>局部内部类</li><li>匿名内部类</li></ol></blockquote><h4 id="13-成员内部类"><a class="markdownIt-Anchor" href="#13-成员内部类"></a> 1.3 成员内部类</h4><blockquote><p>定义格式：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> 外部类</span>&#123;修饰符 <span class="hljs-class"><span class="hljs-keyword">class</span> 内部类</span>&#123;<span class="hljs-comment">// 内部类的成员</span>&#125;<span class="hljs-comment">// 外部类的其他成员</span>&#125;</code></pre></blockquote><blockquote><p>访问规则：</p><ol><li><p>内部类访问外部类：</p><ol><li>内部类可以直接访问外部类的成员，包括私有的</li><li>内部类和外部类中出现同名成员时，可以通过：<ol><li>外部类.this.成员</li><li>在内部类中创建外部类的对象，进行调用</li></ol></li></ol></li><li><p>外部类访问内部类：在外部类中创建内部类的对象，进行调用</p></li><li><p>其他类访问内部类：</p><ol><li><p>通过外部类间接访问：在外部类的方法中，创建内部类的对象，访问内部类的成员，再在其他类中通过外部类使用到内部类</p></li><li><p>直接创建内部类对象：</p><pre><code class="hljs java">外部类.内部类 对象名 = <span class="hljs-keyword">new</span> 外部类().new 内部类();</code></pre></li></ol></li></ol></blockquote><h4 id="14-静态内部类"><a class="markdownIt-Anchor" href="#14-静态内部类"></a> 1.4 静态内部类</h4><blockquote><p>定义格式：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> 外部类</span>&#123;修饰符 <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> 内部类</span>&#123;<span class="hljs-comment">// 内部类的成员</span>&#125;<span class="hljs-comment">// 外部类的其他成员</span>&#125;</code></pre></blockquote><blockquote><p>成员变量的特点：</p><ol><li>如果内部类中的成员变量是静态的，那么这个内部类也必须是静态的，除非这个成员变量是静态常量</li></ol><p>成员方法的特点：</p><ol><li>如果内部类中的成员方法是静态的，那么这个内部类也必须是静态的</li></ol></blockquote><blockquote><p>访问规则：</p><ol><li>内部类访问外部类：<ol><li>静态内部类只能直接访问外部类中的静态成员</li><li>外部类中的非静态成员，必须通过外部类的对象才能访问</li></ol></li><li>外部类访问内部类：必须在外部类中创建内部类的对象，进行访问</li><li>其他类访问静态内部类：<ol><li>如果静态内部类的成员是静态的：外部类.内部类.成员;</li><li>如果静态内部类的成员不是静态的：可以在其他类中直接创建静态内部类的对象，进行调用</li></ol></li></ol></blockquote><h4 id="15-局部内部类"><a class="markdownIt-Anchor" href="#15-局部内部类"></a> 1.5 局部内部类</h4><blockquote><p>概念：将一个类定义在其他类的方法中</p><p>定义格式：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> 外部类</span>&#123;范围修饰符 返回类型 方法名(参数)&#123;        <span class="hljs-class"><span class="hljs-keyword">class</span> 内部类</span>&#123;            <span class="hljs-comment">// 内部类的成员</span>        &#125;    &#125;&#125;</code></pre></blockquote><blockquote><p>访问规则：</p><ol><li>内部类访问外部类：</li><li>内部类可以直接访问外部类的成员，包括私有的</li><li>内部类和外部类中出现同名成员时，可以通过：<ol><li>外部类.this.成员</li><li>在内部类中创建外部类的对象，进行调用</li></ol></li><li>外部类访问内部类：只能在外部类的方法中调用定义局部内部类的方法，并且需要在定义局部内部类的语句后创建该类对象才能调用它的成员</li><li>其他类访问内部类：需要通过外部类的对象调用定义了局部内部类的方法，并且需要在定义局部内部类的语句后创建该类对象才能调用它的成员</li></ol></blockquote><h4 id="16-匿名内部类"><a class="markdownIt-Anchor" href="#16-匿名内部类"></a> 1.6 匿名内部类</h4><blockquote><p>作用：可以通过匿名的方法创建抽象类的子类对象或者接口的实现类对象，从而使代码更加简洁</p><p>格式：</p><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> 类名</span>&#123;<span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> 抽象方法();&#125;<span class="hljs-comment">// 写法：</span><span class="hljs-keyword">new</span> 类名()&#123;重写抽象方法;&#125;;<span class="hljs-class"><span class="hljs-keyword">interface</span> 接口名</span>&#123;<span class="hljs-keyword">void</span> 抽象方法();&#125;<span class="hljs-comment">// 写法：</span><span class="hljs-keyword">new</span> 接口名()&#123;重写抽象方法;&#125;;</code></pre></blockquote><h3 id="二代码块"><a class="markdownIt-Anchor" href="#二代码块"></a> 二，代码块</h3><h4 id="21-概念"><a class="markdownIt-Anchor" href="#21-概念"></a> 2.1 概念</h4><blockquote><p>概念：使用一对大括号括起来的代码段就是一个代码块</p></blockquote><h4 id="22-分类"><a class="markdownIt-Anchor" href="#22-分类"></a> 2.2 分类</h4><blockquote><ol><li>普通代码块</li><li>静态代码块</li><li>构造代码块</li><li>同步代码块（线程）</li></ol></blockquote><h4 id="23-普通代码块"><a class="markdownIt-Anchor" href="#23-普通代码块"></a> 2.3 普通代码块</h4><blockquote><p>写在局部位置的代码块</p><p>注：变量只有在定义它的代码块中才可以使用，代码块结束了，代码块中定义的变量也就被释放了</p><pre><code class="hljs java"><span class="hljs-keyword">int</span> j = <span class="hljs-number">4</span>;&#123;    <span class="hljs-keyword">int</span> k = <span class="hljs-number">7</span>;    System.out.println(j);&#125;System.out.println(k);<span class="hljs-comment">// 报错，k只能在定义它的代码块中使用</span></code></pre></blockquote><h4 id="24-静态代码块"><a class="markdownIt-Anchor" href="#24-静态代码块"></a> 2.4 静态代码块</h4><blockquote><p>概念：在成员位置上，使用 static 修饰的代码块就是静态代码块</p><p>格式：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> 类名</span>&#123;<span class="hljs-keyword">static</span>&#123;<span class="hljs-comment">// 静态代码块中的内容</span>&#125;&#125;</code></pre><p>特点：</p><ol><li>静态代码块最优先执行</li><li>静态代码块只会执行一次</li></ol><p>作用：</p><ol><li>读取配置信息，加载配置内容</li><li>对静态属性进行一次性的赋值</li></ol><p>适用场景：</p><ol><li>共享数据</li></ol><p>注：多个静态代码块会根据书写的先后顺序依次执行</p></blockquote><h4 id="25-构造代码块"><a class="markdownIt-Anchor" href="#25-构造代码块"></a> 2.5 构造代码块</h4><blockquote><p>概念：定义在成员位置上，没有任何修饰符的代码块</p><p>格式：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> 类名</span>&#123;&#123;<span class="hljs-comment">// 代码</span>&#125;<span class="hljs-keyword">public</span> 类名()&#123;&#125;&#125;</code></pre><p>特点：</p><ol><li>优先于构造函数执行，晚于静态代码块执行</li><li>每次创建对象时，都会执行</li></ol><p>作用：为对象的那些不是类的基本信息的属性进行初始化</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>多态</title>
    <link href="/2019/02/10/%E5%A4%9A%E6%80%81/"/>
    <url>/2019/02/10/%E5%A4%9A%E6%80%81/</url>
    
    <content type="html"><![CDATA[<h3 id="一多态的概念"><a class="markdownIt-Anchor" href="#一多态的概念"></a> 一，多态的概念</h3><blockquote><p>面向对象的三大特性：封装、继承、多态</p><p>多态的前提是继承关系或者实现关系</p><p>生活中的多态：不同人物角色在不同的场景下具有不同的身份</p><p>程序中的多态：“一个子类就是一个父类”，父类的引用变量指向子类对象，从而形成多态。</p><p>写法：</p><pre><code class="hljs java">&gt;<span class="hljs-comment">// 例如：Stdeunt继承了Human</span>&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Human</span></span>&#123;&gt;&#125;&gt;Human h = <span class="hljs-keyword">new</span> Student();&gt;<span class="hljs-comment">// 父类 变量名 = new 子类();</span></code></pre><pre><code class="hljs java">&gt;<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Net</span></span>&#123;&gt;&#125;&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Phone</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Net</span></span>&#123;&gt;&#125;&gt;Net n = <span class="hljs-keyword">new</span> Phone;&gt;<span class="hljs-comment">// 接口 变量名 = new 实现类();</span></code></pre></blockquote><h3 id="二多态下成员的特点"><a class="markdownIt-Anchor" href="#二多态下成员的特点"></a> 二，多态下成员的特点</h3><h4 id="21-成员变量的特点"><a class="markdownIt-Anchor" href="#21-成员变量的特点"></a> 2.1 成员变量的特点</h4><blockquote><p>编译时期：父类中没有这个变量，编译失败；父类中有这个变量，编译通过。</p><p>运行时期：访问的是父类中的成员变量</p><p>小结：编译运行都看左边。</p><p>注：多态的情况下，不能访问子类的特有属性</p></blockquote><h4 id="22-成员方法的特点"><a class="markdownIt-Anchor" href="#22-成员方法的特点"></a> 2.2 成员方法的特点</h4><blockquote><p>编译时期：父类中没有这个方法，编译失败；父类中有这个方法，编译通过。</p><p>运行时期：调用的是子类中的成员方法</p><p>小结：编译看左边，运行看右边。</p><p>注：多态的情况下，不能访问子类的特有方法</p></blockquote><h3 id="三多态的应用"><a class="markdownIt-Anchor" href="#三多态的应用"></a> 三，多态的应用</h3><blockquote><p>适用场景1：使用父类作为方法的形参，使方法的实参更加灵活，因为此时方法的实参可以是该父类的任何一个子类。</p><p>适用场景2：适用父类作为方法的返回类型，使方法的返回更加灵活，因为此时方法的返回类型可以是该父类的任何一个子类。</p><p>适用场景3：当使用匿名内部类的方式来创建抽象类的子类对象或者接口的实现类对象时，可以使用抽象类或者接口的引用变量来接收这个匿名对象，此时这个匿名对象有了引用变量名后就可以通过该变量反复调用匿名内部类中的成员。</p></blockquote><h3 id="四多态的转型问题"><a class="markdownIt-Anchor" href="#四多态的转型问题"></a> 四，多态的转型问题</h3><h4 id="41-向上转型"><a class="markdownIt-Anchor" href="#41-向上转型"></a> 4.1 向上转型</h4><blockquote><p>多态的本质就是向上转型，父类的引用变量指向子类对象</p><p>注：向上转型是不会发生异常的，一定是安全的</p><p>多态也就是向上转型后的弊端是无法访问子类的特有内容</p></blockquote><h4 id="42-向下转型"><a class="markdownIt-Anchor" href="#42-向下转型"></a> 4.2 向下转型</h4><blockquote><p>多态的情况下，无法访问子类的特有内容，需要向下转型</p><p>格式：</p><pre><code class="hljs java">子类 变量名 = (子类/实现类)父类/接口引用变量;</code></pre><pre><code class="hljs java">Human h = <span class="hljs-keyword">new</span> Teacher();Teacher t = (Teacher)h;t.teach();<span class="hljs-comment">// 特有方法</span>System.out.println(t.age);<span class="hljs-comment">// 特有属性</span></code></pre></blockquote><blockquote><p>注：在进行向下转型的过程中，如果强转的目标类型不是多态时指定的类型会发生</p><p>类型转换异常(ClassCastException)</p><p>避免类型转换异常需要使用关键字 instanceof</p><p>格式：</p><pre><code class="hljs java">对象 <span class="hljs-keyword">instanceof</span> 类型</code></pre><p>作用：判断对象是否是根据指定类型创建的；判断对象是否可以通过指定的类型来创建。返回布尔值。</p><p>instanceof 的细节：</p><ol><li>没有多态使用 instanceof 是没有意义的</li><li>在没有多态的情况下使用 instanceof 连接一个除自己和父类以外的任何类都会编译失败</li><li>在多态下，instanceof 后连接的是父类名是没有意义的，因为结果永远为真</li><li>在多态下，instanceof 后连接的当前继承体系之外的任何类时都会编译失败</li></ol></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>抽象类</title>
    <link href="/2019/02/10/%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
    <url>/2019/02/10/%E6%8A%BD%E8%B1%A1%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h3 id="一抽象方法和抽象类的概念"><a class="markdownIt-Anchor" href="#一抽象方法和抽象类的概念"></a> 一，抽象方法和抽象类的概念</h3><blockquote><p>概念：当子类的共性方法抽取到父类中，而父类无法描述每个子类的具体行为时，就应该将这个方法定义成抽象方法。</p><p>关键字：abstract</p><p>抽象方法的定义格式：</p><pre><code class="hljs java">范围修饰符 <span class="hljs-keyword">abstract</span> 返回类型 方法名(参数);</code></pre><p>抽象方法必须在抽象类中，所以必须将抽象方法所在的类定义成抽象类。</p></blockquote><h3 id="二抽象类和抽象方法的使用"><a class="markdownIt-Anchor" href="#二抽象类和抽象方法的使用"></a> 二，抽象类和抽象方法的使用</h3><blockquote><p>抽象类一定是一个父类，因为抽象类是向上抽象形成的。</p><p>那么子类中也就存在了从父类中继承下来的抽象方法。</p><p>此时子类要么也是一个抽象类，要么重写父类中的所有抽象方法。</p><p>（子类如果不重写父类中的所有抽象方法，那么这个子类也是一个抽象类）</p><p>抽象类的使用步骤：</p><ol><li>创建子类继承抽象类</li><li>重写所有抽象方法</li><li>创建子类对象调用方法</li></ol></blockquote><h3 id="三注意事项"><a class="markdownIt-Anchor" href="#三注意事项"></a> 三，注意事项</h3><blockquote><ol><li><p>抽象类不能创建对象（不能实例化，不能new）</p><p>原因：如果创建了抽象类的对象，就可以调用抽象的方法，而调用抽象方法没有意义。</p></li><li><p>抽象类中可以有非抽象方法，为子类提供共性方法</p></li><li><p>抽象类中可以有构造函数</p></li><li><p>抽象类一定是一个父类</p></li><li><p>抽象类中可以没有抽象方法</p></li></ol></blockquote><h3 id="四匿名对象"><a class="markdownIt-Anchor" href="#四匿名对象"></a> 四，匿名对象</h3><blockquote><p>概念：创建对象不指定对象的引用变量名</p><p>好处：书写简便</p><p>弊端：</p><ol><li>可读性差</li><li>只能使用一次</li></ol></blockquote><h3 id="五匿名内部类"><a class="markdownIt-Anchor" href="#五匿名内部类"></a> 五，匿名内部类</h3><blockquote><p>概念：使用匿名的方式创建一个抽象类的子类对象</p><p>格式：</p><pre><code class="hljs java"><span class="hljs-keyword">new</span> 抽象类()&#123;重写方法&#125;;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span></span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">// 创建匿名内部类</span><span class="hljs-keyword">new</span> Animal()&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//...</span>&#125;&#125;;</code></pre><p>注：</p><ol><li>匿名内部类中不能写构造函数，因为没有类名</li><li>普通类也可以有匿名内部类，但是不推荐</li><li>匿名内部类创建出的对象可以通过多态使用父类的引用变量接收（后面讲）</li></ol></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>修饰符</title>
    <link href="/2019/02/09/%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
    <url>/2019/02/09/%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h3 id="一包和导入"><a class="markdownIt-Anchor" href="#一包和导入"></a> 一，包和导入</h3><h4 id="11-包"><a class="markdownIt-Anchor" href="#11-包"></a> 1.1 包</h4><blockquote><p>包：本质就是文件夹</p><p>问：为什么要创建不同的包？</p><p>答：因为一个项目中会涉及到很多功能模块、会涉及到很多相关技术，创建不同的包，就是在创建不同的文件夹，当我们将相关的类放入到对应的文件夹（包）之后，类会更加便于管理。</p><p>关键字：package</p><p>注：</p><ol><li>每一类都应该在一个包中，并且这个类的第一行必须明确这个类的包路径（也就是明确这个类是属于哪个包的）</li></ol><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.qf.test;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;    &#125;</code></pre><ol start="2"><li>一个类的完整路径（类全名、全类名）</li></ol><pre><code class="hljs java">com.qf.test.Test;</code></pre></blockquote><h4 id="12-包的命名"><a class="markdownIt-Anchor" href="#12-包的命名"></a> 1.2 包的命名</h4><blockquote><p>规则：由数字、字母、下划线、美元符组成，数字不能开头</p><p>规范：全小写，用 “.” 来划分不同层级的文件夹，经常使用域名倒着写。</p></blockquote><blockquote><p>一般包名的定义：</p><ol><li>实体类：entity、domain、pojo、vo</li><li>工具类：util</li><li>测试类：test</li><li>数据库相关：dao</li><li>业务逻辑层：business、service</li><li>控制层：controller</li></ol></blockquote><h4 id="13-导入"><a class="markdownIt-Anchor" href="#13-导入"></a> 1.3 导入</h4><blockquote><p>导包：当一个类中使用到了其他包中的类时，需要将这个类的资源引入进来。</p><p>注：同包中其他类的访问是不需要导包的。</p><p>导入的关键字：import</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> 完整包名.类名;</code></pre><p>按需导入：</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;可以代替<span class="hljs-keyword">import</span> java.util.Random;<span class="hljs-keyword">import</span> java.util.Scanner;...</code></pre><p>注：java.lang 中的类不需要手动导入，会自动导入</p></blockquote><h3 id="二范围权限修饰符"><a class="markdownIt-Anchor" href="#二范围权限修饰符"></a> 二，范围（权限）修饰符</h3><blockquote><ol><li>public：公共的、公开的</li><li>protected：受保护的</li><li>[default]：默认的，在方法、成员变量前不定义任何范围修饰符</li><li>private：私有的</li></ol><p>注：范围修饰符只能修饰成员</p></blockquote><blockquote><p>​                            public             protected                 [default]               private</p><p>本类中                              可以                        可以                         可以                     可以</p><p>同包不同类                      可以                        可以                         可以                     不可以</p><p>不同包的子类                  可以                        可以                         不可以                 不可以</p><p>不同包的无关类              可以                        不可以                     不可以                 不可以</p></blockquote><blockquote><p>适用场景：</p><ol><li>public：对外提供公共方法</li><li>protected：父类功能需要其他包中的子类进行功能扩展时</li><li>[default]：只允许在同包中使用的成员</li><li>private：属性的私有化，用于辅助当前类中其他功能的执行而不应该直接被外界访问的方法</li></ol></blockquote><h3 id="三静态"><a class="markdownIt-Anchor" href="#三静态"></a> 三，静态</h3><blockquote><p>静态的关键字：static</p></blockquote><h4 id="31-静态的特点"><a class="markdownIt-Anchor" href="#31-静态的特点"></a> 3.1 静态的特点</h4><blockquote><ol><li>当一个类被加载到内存时，静态成员会随着类的加载而加载</li><li>被静态所修饰的成员，不属于对象，而属于类</li><li>被静态所修饰符的成员可以直接使用类名进行调用</li><li>被静态所修饰的成员是整个类的共享数据</li><li>静态成员只能访问静态的，不能访问非静态的；非静态的成员既能访问静态的也能访问非静态的</li><li>静态成员不能访问 super 或者 this</li><li>静态只能修饰成员</li></ol></blockquote><h4 id="32-静态代码块"><a class="markdownIt-Anchor" href="#32-静态代码块"></a> 3.2 静态代码块</h4><blockquote><p>格式：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> 类名</span>&#123;<span class="hljs-keyword">static</span>&#123;<span class="hljs-comment">// 静态代码块中的内容</span>&#125;&#125;</code></pre><p>特点：</p><ol><li>静态代码块最优先执行</li><li>静态代码块只会执行一次</li></ol><p>作用：</p><ol><li>读取配置信息，加载配置内容</li><li>对静态属性进行一次性的赋值</li></ol><p>适用场景：</p><ol><li>共享数据</li></ol><p>注：多个静态代码块会根据书写的先后顺序依次执行</p></blockquote><h4 id="33-静态常量"><a class="markdownIt-Anchor" href="#33-静态常量"></a> 3.3 静态常量</h4><blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> 数据类型 变量名 = 值;</code></pre></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>继承</title>
    <link href="/2019/02/09/%E7%BB%A7%E6%89%BF/"/>
    <url>/2019/02/09/%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<h3 id="一继承的概念"><a class="markdownIt-Anchor" href="#一继承的概念"></a> 一，继承的概念</h3><blockquote><p>生活中的继承：子女拥有父母的东西</p><p>代码中继承：指的是类与类之间产生了关系，多个类有共性内容后向上抽取</p></blockquote><blockquote><p>父类：超类、基类</p><p>​父类的范围往往比较大，但是属性和方法一般都比较少</p><p>子类：派生类、衍生类</p><p>​子类的范围往往更精细，属性、方法一般都比较多</p><p>所有类都直接或者间接的继承了 Object 类</p><p>注：子类的命名一般使用父类的名字作为后缀</p></blockquote><h3 id="二继承的好处"><a class="markdownIt-Anchor" href="#二继承的好处"></a> 二，继承的好处</h3><blockquote><ol><li>子类可以直接访问父类中非私有的成员，提高了代码复用性</li><li>为多态提供了前提</li></ol></blockquote><h3 id="三子类父类的继承关系"><a class="markdownIt-Anchor" href="#三子类父类的继承关系"></a> 三，子类父类的继承关系</h3><blockquote><p>关键字：extends</p><pre><code class="hljs java"><span class="hljs-comment">// 父类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span></span>&#123;<span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> age;<span class="hljs-keyword">public</span> String name;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span></span>&#123;&#125;&#125;<span class="hljs-comment">// 子类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Human</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span></span>&#123;&#125;</code></pre></blockquote><blockquote><p>注：</p><ol><li>多个子类可以继承同一个父类</li><li>一个类不能同时继承多个父类</li><li>继承具有传递性</li></ol></blockquote><h3 id="四子类父类中同名成员的问题"><a class="markdownIt-Anchor" href="#四子类父类中同名成员的问题"></a> 四，子类父类中同名成员的问题</h3><h4 id="41-同名变量"><a class="markdownIt-Anchor" href="#41-同名变量"></a> 4.1 同名变量</h4><blockquote><p>当子父类中出现同名变量时，会根据 “就近原则”，优先获取子类中的成员。</p><p>如果要在子类中访问父类中的同名变量，可以使用关键字 super 来调用。</p><p>super 表示父类的对象。</p></blockquote><h4 id="41-同名方法重写-override"><a class="markdownIt-Anchor" href="#41-同名方法重写-override"></a> 4.1 同名方法（重写 override）</h4><blockquote><p>重写的概念：在继承关系中，子类对父类的功能进行扩展就是方法的重写。</p><p>重写的格式：</p><ol><li><strong>方法的参数列表相同</strong></li><li><strong>方法名相同</strong></li><li>子类重写方法的范围修饰符要大于等于父类的<ol><li>public &gt; protected &gt; [default] &gt; private</li></ol></li><li>返回类型是引用数据类型时，子类重写方法的返回类型必须是父类方法返回的类型或者是该类型的子类</li></ol></blockquote><blockquote><p>注：</p><ol><li>可以使用 @Override 来校验当前的方法定义是否是在重写</li><li>即使子类重写了父类的方法，对父类的方法进行了功能上的扩展，也不能删除父类原有功能</li><li>子类在重写父类功能时，如果要想访问到父类的同名方法，可以使用 super 调用</li></ol></blockquote><h3 id="五父类属性私有化的问题"><a class="markdownIt-Anchor" href="#五父类属性私有化的问题"></a> 五，父类属性私有化的问题</h3><blockquote><p>问题：当父类属性私有化后，对子类就不可见了，子类无法访问到这些私有属性。</p><p>解决：</p><p>方式一：父类属性私有化了，但是对外提供的 set/get 方法可以访问，所以子类可以借助父类的 set/get 方法来访问到父类的私有属性</p><p>方式二：如果子类想在创建对象时对这些私有化的属性进行初始化，就需要在子类的重载构造函数中调用父类的重载构造函数</p><pre><code class="hljs java">&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Gun</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Weapon</span> </span>&#123;<span class="hljs-comment">// 子弹数量</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Gun</span><span class="hljs-params">(String brand, String type, <span class="hljs-keyword">double</span> price, <span class="hljs-keyword">int</span> count)</span> </span>&#123;<span class="hljs-keyword">super</span>(brand, type, price);<span class="hljs-keyword">this</span>.count = count;&#125;&gt;&#125;</code></pre></blockquote><h3 id="六子父类中构造函数的关系和特点"><a class="markdownIt-Anchor" href="#六子父类中构造函数的关系和特点"></a> 六，子父类中构造函数的关系和特点</h3><blockquote><ol><li>每一个类的每一个构造函数中都调用了父类中默认的无参构造函数</li><li>如果重载了构造函数，那么默认的无参构造函数就不存在了</li><li>如果父类中重载了构造函数并且没有写出默认的无参构造函数，那么子类会报错，因为子类中的默认构造函数中无法调用到父类无参构造函数。一般会重载子类的构造函数，并在函数中调用父类的重载构造函数。</li><li>父类构造函数的调用必须在子类构造函数的第一行</li></ol></blockquote><h3 id="七-super-关键字"><a class="markdownIt-Anchor" href="#七-super-关键字"></a> 七， super 关键字</h3><blockquote><p>super 表示父类的对象</p><p>super 的作用：</p><ol><li>调用父类的属性、调用父类的方法</li><li>调用父类的构造函数</li></ol></blockquote><h3 id="八final-关键字"><a class="markdownIt-Anchor" href="#八final-关键字"></a> 八，final 关键字</h3><blockquote><p>final 可以修饰：</p><ol><li><p>变量：变成了常量，常量不能重新赋值</p><p>注：final 修饰成员变量时，这个变量必须手动初始化</p></li><li><p>对象：对象创建后，不能指向其他的地址</p></li><li><p>类：变成最终类，不能被继承</p></li><li><p>方法：变成最终方法，不能被重写</p></li></ol></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>封装</title>
    <link href="/2019/02/09/%E5%B0%81%E8%A3%85/"/>
    <url>/2019/02/09/%E5%B0%81%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h3 id="一封装的概念"><a class="markdownIt-Anchor" href="#一封装的概念"></a> 一，封装的概念</h3><blockquote><p>生活中的封装：打包盒、机箱</p><p>代码中封装：方法、包、类</p><p>概念：隐藏内部的实现细节</p></blockquote><h3 id="二封装的好处"><a class="markdownIt-Anchor" href="#二封装的好处"></a> 二，封装的好处</h3><blockquote><ol><li>隐藏了实现细节</li><li>提高了代码的安全性</li><li>提高了代码的复用性</li></ol></blockquote><h3 id="三封装的必要性"><a class="markdownIt-Anchor" href="#三封装的必要性"></a> 三，封装的必要性</h3><blockquote><p>问题：</p><ol><li>属性可以通过对象随意调用</li><li>对属性值没有合理性的判断</li></ol><p>解决：</p><ol><li>可以通过对属性进行私有化的封装来限制属性的调用</li><li>对属性值进行合理性的判断</li></ol></blockquote><h3 id="四如何对属性进行封装"><a class="markdownIt-Anchor" href="#四如何对属性进行封装"></a> 四，如何对属性进行封装</h3><h4 id="41-对属性进行私有化"><a class="markdownIt-Anchor" href="#41-对属性进行私有化"></a> 4.1 对属性进行私有化</h4><blockquote><p>实现方式：使用关键字 private 修饰属性</p><p>private：private 关键字是范围（权限）修饰符中的一个，表示私有的，被 private 所修饰的成员只能在本类访问，对其他类来说这个成员是不可见的。</p></blockquote><h4 id="42-对外提供这个私有属性的访问方法并在方法中进行合理性的判断"><a class="markdownIt-Anchor" href="#42-对外提供这个私有属性的访问方法并在方法中进行合理性的判断"></a> 4.2 对外提供这个私有属性的访问方法，并在方法中进行合理性的判断</h4><blockquote><p>赋值：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span></span>&#123;<span class="hljs-keyword">this</span>.age = age;&#125;</code></pre><p>获取：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.age;&#125;</code></pre></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>方法</title>
    <link href="/2019/02/08/%E6%96%B9%E6%B3%95/"/>
    <url>/2019/02/08/%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数组</title>
    <link href="/2019/02/08/%E6%95%B0%E7%BB%84/"/>
    <url>/2019/02/08/%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h3 id="一概念和特点"><a class="markdownIt-Anchor" href="#一概念和特点"></a> 一，概念和特点</h3><blockquote><p>概念：用于存储数据的容器</p><p>特点：</p><ol><li>只能存储同一种数据类型（定义时如果明确了数组的数据类型，那么该数组只能存储这个类型的元素）</li><li>数组的长度固定（定义时数组的长度就应该被明确，在之后的操作中该数组的长度不能发生变化）</li></ol></blockquote><h3 id="二数组的定义和创建"><a class="markdownIt-Anchor" href="#二数组的定义和创建"></a> 二，数组的定义和创建</h3><blockquote><p>格式：</p><ol><li><pre class="highlight"><code class="java">数据类型[] 数组名 = <span class="hljs-keyword">new</span> 数据类型[数组的长度];&lt;!--code￼<span class="hljs-number">0</span>--&gt;</code></pre></li><li><pre class="highlight"><code class="java">数据类型[] 数组名 = &#123;值<span class="hljs-number">1</span>,值<span class="hljs-number">2</span>,值<span class="hljs-number">3</span>,值<span class="hljs-number">4</span>...&#125;;&lt;!--code￼<span class="hljs-number">1</span>--&gt;</code></pre></li></ol><p>数组名[ 下标 ]</p><pre><code class="hljs yaml"><span class="hljs-string">&gt;注：</span><span class="hljs-number">1</span><span class="hljs-string">.</span><span class="hljs-string">如果下标超过了范围会发生异常：ArrayIndexOutOfBoundsException</span> <span class="hljs-string">数组下标越界</span><span class="hljs-number">2</span><span class="hljs-string">.</span><span class="hljs-string">如果数组只定义了长度，没有给初始值，那么数组中的元素会有默认值，默认值与数组的类型相关</span> <span class="hljs-number">1</span><span class="hljs-string">.</span><span class="hljs-string">整型的默认值是</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span><span class="hljs-string">.</span><span class="hljs-string">浮点型的默认值是</span> <span class="hljs-number">0.0</span> <span class="hljs-number">3</span><span class="hljs-string">.</span><span class="hljs-string">字符型的默认值是一个空格</span> <span class="hljs-number">4</span><span class="hljs-string">.</span><span class="hljs-string">布尔型的默认值是</span> <span class="hljs-literal">false</span> <span class="hljs-number">5</span><span class="hljs-string">.</span><span class="hljs-string">引用数据类型的默认值是</span> <span class="hljs-literal">null</span><span class="hljs-comment">#### 3.2 赋值</span><span class="hljs-string">格式：</span><span class="hljs-string">```java</span><span class="hljs-string">数组名[</span> <span class="hljs-string">下标</span> <span class="hljs-string">]</span> <span class="hljs-string">=</span> <span class="hljs-string">值;</span></code></pre></blockquote><h4 id="33-注意事项"><a class="markdownIt-Anchor" href="#33-注意事项"></a> 3.3 注意事项</h4><blockquote><ol><li>无论是赋值还是获取，下标的范围都是 0 ~ 数组长度 - 1</li><li>数组长度的获取方式：数组名.length</li><li>直接打印数组名，如果是 char 类型的数组，会输出根据ASCII码表的对应值；如果不是 char 类型的数组，会输出这个数组在内存中的存储地址</li><li>数组的工具类中提供了获取数组中获取元素的方法。数组的工具类：Arrays，方法是toString(数组)</li></ol></blockquote><h3 id="四数组的遍历"><a class="markdownIt-Anchor" href="#四数组的遍历"></a> 四，数组的遍历</h3><blockquote><p>遍历就是对数组进行循环，获取到数组中的每一个元素</p></blockquote><h3 id="五foreach循环"><a class="markdownIt-Anchor" href="#五foreach循环"></a> 五，foreach循环</h3><blockquote><p>foreach 循环也叫增强 for 循环，专门用于遍历容器（数组、集合、Map）</p><p>格式：</p><pre><code class="hljs java"><span class="hljs-keyword">for</span>(数据类型 变量 : 容器)&#123;循环体&#125;</code></pre><p>注：</p><ol><li>这个变量在每次循环时，都会接收到当前遍历到的元素</li><li>增强 for 循环中没有下标的概念</li><li>习惯上，增强 for 循环只为了遍历整个容器中的内容；如果循环体中的操作要和下标结合，还是推荐普通 for 循环</li></ol></blockquote><h3 id="六数组的复制"><a class="markdownIt-Anchor" href="#六数组的复制"></a> 六，数组的复制</h3><blockquote><p>方法一：</p><p>遍历原始数组中的每一个元素，将它们分别赋值到新数组中</p><p>方式二：</p><p>使用 System 系统类所提供的 arrayCopy 方法</p><p>方式三：</p><p>使用 Arrays 数组工具类所提供的 copyOf 方法</p></blockquote><h3 id="七数组的地址"><a class="markdownIt-Anchor" href="#七数组的地址"></a> 七，数组的地址</h3><blockquote><p>数组是引用数据类型，只要是一个引用数据类型，在创建时就会在堆内存中开辟存储空间，而每一个开辟的空间都有自己的地址。打印数组地址会输出这个数组在堆内存中的存储地址。</p><p>当数组的引用变量被赋值时，那么这个数组就指向了新的地址。</p><p>在完成了数组的复制后，新数组中的内容与原始数组中的内容相同，但是地址不相同。</p></blockquote><h3 id="八二维数组"><a class="markdownIt-Anchor" href="#八二维数组"></a> 八，二维数组</h3><h4 id="81-概念"><a class="markdownIt-Anchor" href="#81-概念"></a> 8.1 概念</h4><blockquote><p>二维数组是数组的数组，二维数组中的每一个元素都是一个一维数组</p></blockquote><h4 id="82-二维数组的创建"><a class="markdownIt-Anchor" href="#82-二维数组的创建"></a> 8.2 二维数组的创建</h4><blockquote><p>方式一：</p><pre><code class="hljs java">数据类型[][] 数组名 = <span class="hljs-keyword">new</span> 数据类型[n][m];<span class="hljs-keyword">int</span>[][] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>];<span class="hljs-comment">// 表示创建了一个二维数组arr，这个二维数组有3个元素（长度为3），每个一维数组有4个元素（长度为4）</span></code></pre><p>方式二：</p><pre><code class="hljs java">数据类型[][] 数组名 = <span class="hljs-keyword">new</span> 数据类型[n][];</code></pre><p>注：</p><ol><li>使用这个方式创建的二维数组中的每一个一维数组都需要再单独创建（分配空间），否则会发生 NullPointerException，空指针异常。</li><li>一维数组的创建不能使用简化动作</li></ol><p>方式三：</p><pre><code class="hljs java">数据类型[][] 数组名 = &#123;&#123;值<span class="hljs-number">1</span>,值<span class="hljs-number">2</span>,...&#125;,&#123;值<span class="hljs-number">1</span>,...&#125;,&#123;值<span class="hljs-number">1</span>,值<span class="hljs-number">2</span>,值<span class="hljs-number">3</span>,...&#125;&#125;;</code></pre></blockquote><h4 id="83-二维数组的遍历"><a class="markdownIt-Anchor" href="#83-二维数组的遍历"></a> 8.3 二维数组的遍历</h4><blockquote><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt;= arr.length - <span class="hljs-number">1</span>;i++)&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt;= arr[i].length - <span class="hljs-number">1</span>;j++)&#123;    System.out.print(arr[i][j]);    &#125;    System.out.println();&#125;</code></pre></blockquote><blockquote><pre><code class="hljs java"><span class="hljs-keyword">for</span>(数据类型[] 每次遍历到的一维数组的变量 : 二维数组)&#123;<span class="hljs-keyword">for</span>(数据类型 变量 : 一维数组)&#123;循环体&#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] sb : arr)&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> t : sb)&#123;System.out.print(t);&#125;System.out.println();&#125;</code></pre></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>流程控制</title>
    <link href="/2019/02/08/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <url>/2019/02/08/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="一分支结构"><a class="markdownIt-Anchor" href="#一分支结构"></a> 一，分支结构</h3><h4 id="11-单-if-结构"><a class="markdownIt-Anchor" href="#11-单-if-结构"></a> 1.1 单 if 结构</h4><blockquote><p>格式：</p><pre><code class="hljs java"><span class="hljs-keyword">if</span>(条件表达式)&#123;语句&#125;</code></pre><p>逻辑：判断条件表达式的结果，结果为true，执行代码块中的语句；反之，不执行。</p></blockquote><h4 id="12-标准的-if-else-结构"><a class="markdownIt-Anchor" href="#12-标准的-if-else-结构"></a> 1.2 标准的 if-else 结构</h4><blockquote><p>格式：</p><pre><code class="hljs java"><span class="hljs-keyword">if</span>(条件表达式)&#123;语句<span class="hljs-number">1</span>&#125;<span class="hljs-keyword">else</span>&#123;a语句<span class="hljs-number">2</span>&#125;</code></pre><p>逻辑：判断条件表达式，结果为true，执行语句1；反之，执行语句2。</p></blockquote><h4 id="13-多条件的-if-else-结构"><a class="markdownIt-Anchor" href="#13-多条件的-if-else-结构"></a> 1.3 多条件的 if-else 结构</h4><blockquote><p>格式：</p><pre><code class="hljs java"><span class="hljs-keyword">if</span>(条件表达式<span class="hljs-number">1</span>)&#123;语句<span class="hljs-number">1</span>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(条件表达式<span class="hljs-number">2</span>)&#123;语句<span class="hljs-number">2</span>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(条件表达式<span class="hljs-number">3</span>)&#123;语句<span class="hljs-number">3</span>&#125;</code></pre><p>逻辑：依次判断每一个条件表达式，当有一个条件表达式的结果为 true 时，执行相应语句，语句执行完毕后，if-else 结构结束。如果没有一个条件表达式的结果为 true，则不执行任何语句，结束if-else 结构。</p><pre><code class="hljs java"><span class="hljs-keyword">if</span>(条件表达式<span class="hljs-number">1</span>)&#123;语句<span class="hljs-number">1</span>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(条件表达式<span class="hljs-number">2</span>)&#123;语句<span class="hljs-number">2</span>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(条件表达式<span class="hljs-number">3</span>)&#123;语句<span class="hljs-number">3</span>&#125;<span class="hljs-keyword">else</span>&#123;    语句n&#125;</code></pre><p>逻辑：依次判断每一个条件表达式，当有一个条件表达式的结果为true时，执行相应语句，如果没有任何一个条件表达式的结果为true，则执行语句n。</p></blockquote><blockquote><p>注：</p><p>​如果 if 或者 else 后的代码块中只有一条语句，那么大括号可以省略</p></blockquote><h4 id="14-嵌套的-if-else-结构"><a class="markdownIt-Anchor" href="#14-嵌套的-if-else-结构"></a> 1.4 嵌套的 if-else 结构</h4><blockquote><p>if-else 代码块在另一个 if-else 代码块中</p></blockquote><h3 id="二选择结构"><a class="markdownIt-Anchor" href="#二选择结构"></a> 二，选择结构</h3><blockquote><p>格式：</p><pre><code class="hljs java"><span class="hljs-keyword">switch</span>(表达式)&#123;<span class="hljs-keyword">case</span> 值<span class="hljs-number">1</span>:语句<span class="hljs-number">1</span>;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> 值<span class="hljs-number">2</span>:语句<span class="hljs-number">2</span>;<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> 值<span class="hljs-number">3</span>:语句<span class="hljs-number">3</span>;<span class="hljs-keyword">break</span>;...<span class="hljs-keyword">default</span>:语句n;<span class="hljs-keyword">break</span>;&#125;</code></pre><p>逻辑：将表达式的结果与每一个 case 后的值进行比较，当某一个 case 后的值与表达式的结果相同时，执行对应语句；如果没有任何一个 case 后的值与表达式结果相同，执行 default 后的语句。</p></blockquote><blockquote><p>注：</p><ol><li>每一个 case 后的值必须是唯一的</li><li>表达式结果的类型只能是 byte、short、int、char、String（jdk1.7以后才有String）</li><li>表达式结果的类型必须与 case 后值的类型一致</li><li>每一个 case 以及 default 的位置是任意的</li><li>default 只有在没有任何一个 case 后的值与表达式结果相同时，才会执行</li><li>break 的作用是结束整个 switch-case 结构，当删除了 break 后，会产生穿透性</li></ol></blockquote><h3 id="三循环结构"><a class="markdownIt-Anchor" href="#三循环结构"></a> 三，循环结构</h3><blockquote><p>循环必须具备4个要素：</p><ol><li>条件表达式</li><li>循环体</li><li>初始化的值</li><li>步进表达式</li></ol></blockquote><h4 id="31-while-循环"><a class="markdownIt-Anchor" href="#31-while-循环"></a> 3.1 while 循环</h4><blockquote><p>格式：</p><pre><code class="hljs java"><span class="hljs-keyword">while</span>(条件表达式)&#123;循环体&#125;</code></pre><p>逻辑：判断条件表达式的结果，如果是 true 执行循环体，再次判断条件表达式，直到条件表达式的结果为 false，循环结束。</p></blockquote><h4 id="32-do-while-循环"><a class="markdownIt-Anchor" href="#32-do-while-循环"></a> 3.2 do-while 循环</h4><blockquote><p>格式：</p><pre><code class="hljs java"><span class="hljs-keyword">do</span>&#123;循环体&#125;<span class="hljs-keyword">while</span>(条件表达式);</code></pre><p>逻辑：先执行一次循环体，再判断条件，如果条件为 true，执行循环体，再判断条件，直到条件表达式的结果是 false ，结束循环。</p></blockquote><h4 id="33-for-循环"><a class="markdownIt-Anchor" href="#33-for-循环"></a> 3.3 for 循环</h4><blockquote><p>格式：</p><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-number">1</span>初始化;<span class="hljs-number">2</span>条件表达式;<span class="hljs-number">3</span>步进表达式)&#123;<span class="hljs-number">4</span>循环体&#125;</code></pre><p>流程：1243243243243…2</p></blockquote><h4 id="34-break和continue"><a class="markdownIt-Anchor" href="#34-break和continue"></a> 3.4 break和continue</h4><blockquote><p>continue：在循环结构中，用于跳过当前次循环，继续后续的循环</p><p>break：在 switc-case 中用于跳出整个 switc-case 结构，在循环中，用于跳出整个循环，在循环嵌套中，break 只能跳出当前这一层循环。</p></blockquote><h4 id="35-死循环"><a class="markdownIt-Anchor" href="#35-死循环"></a> 3.5 死循环</h4><blockquote><p>概念：死循环就是无限循环，只要没有 break 终止循环，循环体将无穷无尽的运行下去</p></blockquote><blockquote><p>格式：</p><pre><code class="hljs java"><span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">do</span>&#123;&#125;<span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>);</code></pre><pre><code class="hljs java"><span class="hljs-keyword">for</span>(;;)&#123;&#125;</code></pre></blockquote><h4 id="36-循环嵌套"><a class="markdownIt-Anchor" href="#36-循环嵌套"></a> 3.6 循环嵌套</h4><blockquote><p>一个循环的循环体是另一个循环结构</p><p>格式：</p><pre><code class="hljs java"><span class="hljs-keyword">while</span>()&#123;<span class="hljs-keyword">while</span>()&#123;i++;&#125;j++;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">for</span>(;;)&#123;<span class="hljs-keyword">for</span>(;;)&#123;&#125;&#125;</code></pre></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java语法</title>
    <link href="/2019/02/08/Java%E8%AF%AD%E6%B3%95/"/>
    <url>/2019/02/08/Java%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="一变量"><a class="markdownIt-Anchor" href="#一变量"></a> 一，变量</h3><blockquote><p>概念：计算机内存中的一块存储空间，是存储数据的基本单元</p></blockquote><h4 id="11-变量的定义"><a class="markdownIt-Anchor" href="#11-变量的定义"></a> 1.1 变量的定义</h4><blockquote><p>方式一：</p><pre><code class="hljs java"><span class="hljs-comment">// 声明并定义了指定类型的变量（先定义后赋值）</span>数据类型 变量名;变量名 = 值;例如：<span class="hljs-keyword">int</span> age; 声明定义了一个<span class="hljs-keyword">int</span>类型的变量ageage = <span class="hljs-number">25</span>;为age变量赋值为<span class="hljs-number">25</span></code></pre><p>方式二：</p><pre><code class="hljs java"><span class="hljs-comment">// 声明并定义了指定类型的变量同时进行赋值（定义的同时赋值）</span>数据类型 变量名 = 值;例如：<span class="hljs-keyword">double</span> height = <span class="hljs-number">180</span>; 声明定义了一个<span class="hljs-keyword">double</span>类型的变量height并赋值为<span class="hljs-number">180</span></code></pre><p>方式三：</p><pre><code class="hljs java"><span class="hljs-comment">// 多个相同数据类型的变量同时声明赋值</span>数据类型 变量名<span class="hljs-number">1</span> = 值,变量名<span class="hljs-number">2</span>,变量名<span class="hljs-number">3</span> = 值,...;<span class="hljs-comment">// 同时定义3个人的年龄分别为21，24，22</span><span class="hljs-keyword">int</span> age1 = <span class="hljs-number">21</span>,age2 = <span class="hljs-number">24</span>,age3 = <span class="hljs-number">22</span>;</code></pre></blockquote><blockquote><p>注：</p><ol><li>变量在使用前必须先赋值</li><li>变量可以被多次赋值，赋值后新值会覆盖旧值</li><li>变量不能重复定义</li><li>必须先定义变量，才能使用</li><li>变量只能在定义它的代码块中使用，一旦出了定义它的代码块这个变量就从内存中释放了</li></ol></blockquote><h3 id="二数据类型"><a class="markdownIt-Anchor" href="#二数据类型"></a> 二，数据类型</h3><blockquote><p>Java中的数据类型分为：</p><ol><li>基本数据类型</li><li>引用数据类型</li></ol></blockquote><h4 id="21-基本数据类型四类八种"><a class="markdownIt-Anchor" href="#21-基本数据类型四类八种"></a> 2.1 基本数据类型（四类八种）</h4><h5 id="211-整数类型"><a class="markdownIt-Anchor" href="#211-整数类型"></a> 2.1.1 整数类型</h5><blockquote><p>byte：字节，1个字节，范围：-128 ~ 127</p><p>short：短整型，2个字节，范围：-32768 ~ 32767</p><p>int：整型，4个字节，默认整型</p><p>long：长整型，8个字节</p></blockquote><blockquote><p>注：</p><ol><li>值的大小不能超过类型的范围</li><li>如果 long 型的变量接收超过 int 范围的数据时，需要在数据末尾加上“l”或者“L”</li></ol></blockquote><h5 id="212-浮点类型"><a class="markdownIt-Anchor" href="#212-浮点类型"></a> 2.1.2 浮点类型</h5><blockquote><p>float：单精度浮点类型，4个字节</p><p>double：双精度浮点类型，8个字节，默认的浮点类型</p></blockquote><blockquote><p>注：</p><p>​1.对 float 类型的变量进行赋值时，如果值是小数需要加上“F”或者“f”</p></blockquote><h5 id="213-布尔类型"><a class="markdownIt-Anchor" href="#213-布尔类型"></a> 2.1.3 布尔类型</h5><blockquote><p>boolean：1个字节，只有两值 true 、 false</p></blockquote><blockquote><p>注：</p><ol><li>布尔值不能参与算数运算</li><li>布尔值可以参与关系运算、逻辑运算</li></ol></blockquote><h5 id="214-字符类型"><a class="markdownIt-Anchor" href="#214-字符类型"></a> 2.1.4 字符类型</h5><blockquote><p>char：2个字节，表示单个字符，用一对单引号括起来</p></blockquote><blockquote><p>注：</p><ol><li>char 类型的变量可以接收一个汉字</li><li>char 中不能存储空字符</li></ol></blockquote><h5 id="215-转义字符"><a class="markdownIt-Anchor" href="#215-转义字符"></a> 2.1.5 转义字符</h5><blockquote><p>如果在程序中要输出一个单引号，直接定义 char c = ‘’’，会报错。</p><p>我们需要对中间的单引号进行转换。</p><p>转义字符：\</p><p>常见的转义动作：</p><pre><code class="hljs java"><span class="hljs-number">1.</span>\\<span class="hljs-number">2.</span>\<span class="hljs-string">&#x27;</span><span class="hljs-string">3.\&quot;</span><span class="hljs-string">4.\t：一个制表符</span><span class="hljs-string">5.\n：一个换行符</span></code></pre></blockquote><h4 id="22-引用数据类型"><a class="markdownIt-Anchor" href="#22-引用数据类型"></a> 2.2 引用数据类型</h4><h5 id="221-字符串类型"><a class="markdownIt-Anchor" href="#221-字符串类型"></a> 2.2.1 字符串类型</h5><blockquote><p>概念：任何双引号括起来的字面值，例如 “abc” 都是字符串</p><p>String：它在 java.lang 语言包中，在该类中，定义了一系列的用于操作字符串的功能</p><p>定义：</p><pre><code class="hljs java">String 变量名 = <span class="hljs-string">&quot;值&quot;</span>;</code></pre></blockquote><h3 id="三运算符"><a class="markdownIt-Anchor" href="#三运算符"></a> 三，运算符</h3><h4 id="31-算数运算符"><a class="markdownIt-Anchor" href="#31-算数运算符"></a> 3.1 算数运算符</h4><blockquote><ol><li><p>+：求和，如果参与运算的数据中有字符串，那么 “+” 就是拼接，且拼接后的结果仍为字符串</p></li><li><p>-：求差</p></li><li><p>*：求积</p></li><li><p>/：求商</p><p>注：整数之间的除法可能会有精度损失</p></li><li><p>%：取模运算，求余数</p><p>注：</p><ol><li><p>a % b，如果 a &lt; b，那么结果是 a</p><ol start="2"><li>a % b，结果是范围是[0，a)，包含 0，不包含 a</li><li>a % b ，结果的正负与 a 的正负一致</li></ol></li></ol></li><li><p>++：自增1  --：自减1</p><p>注：</p><ol start="7"><li>自增、自减运算分为前置和后置<br />1. 前置：<ins>a、–b<br />2. 后置：a</ins>、b–</li><li>在单独运算时，前置和后置没有区别；如果在复合运算中，<br />1. 前置：先执行自增（减），再执行其他操作<br />2. 后置：先执行其他操作，再执行自增（减）</li></ol></li></ol></blockquote><h4 id="32-赋值运算符"><a class="markdownIt-Anchor" href="#32-赋值运算符"></a> 3.2 赋值运算符</h4><blockquote><ol><li><p>=</p></li><li><p>+=：</p><pre><code class="hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">3</span>;a = a + <span class="hljs-number">4</span>;<span class="hljs-comment">// 等价于 a += 4;</span></code></pre></li><li><p>-=</p></li><li><p>*=</p></li><li><p>/=</p></li><li><p>%=</p></li></ol></blockquote><h4 id="33-关系比较运算符"><a class="markdownIt-Anchor" href="#33-关系比较运算符"></a> 3.3 关系(比较)运算符</h4><blockquote><p>关系运算的运算结果都是布尔值</p></blockquote><blockquote><pre><code class="hljs java"><span class="hljs-number">1.</span> ==：比较参与运算的两个数据是否相等<span class="hljs-number">2.</span> !=：比较参与运算的两个数据是否不等<span class="hljs-number">3.</span> &gt;<span class="hljs-number">4.</span> &lt;<span class="hljs-number">5.</span> &gt;=<span class="hljs-number">6.</span> &lt;=</code></pre></blockquote><h4 id="34-逻辑运算符"><a class="markdownIt-Anchor" href="#34-逻辑运算符"></a> 3.4 逻辑运算符</h4><blockquote><p>逻辑运算的运算结果都是布尔值，参与运算的表达式的结果也必须是布尔值</p></blockquote><blockquote><ol><li>&amp;：逻辑与，并且</li></ol><p>逻辑：表达式两边只要出现了false，整个表达式的结果就是false</p><ol start="2"><li>|：逻辑或，或者</li></ol><p>逻辑：表达式两边只要有true，整个表达式的结果就是true</p><ol start="3"><li><p>!：逻辑非，取反</p></li><li><p>^（了解）：异或</p></li></ol><p>逻辑：表达式两边同为true或者false，结果为false；表达式两边不一样结果为true</p></blockquote><blockquote><p>注：</p><ol><li>多个布尔值参与逻辑运算仍遵循上述的特点</li><li>&amp;&amp;：如果表达式的左边是false，那么整个表达式的结果就是false，因此表达式的右边不再运算</li><li>||：如果表达式的左边是true，那么整个表达式的结果就是true，因此表达式的右边不再运算</li></ol></blockquote><h4 id="35-三元目运算符"><a class="markdownIt-Anchor" href="#35-三元目运算符"></a> 3.5 三元(目)运算符</h4><blockquote><p>？ ：</p><p>格式：</p><pre><code class="hljs java">表达式<span class="hljs-number">1</span>?表达式<span class="hljs-number">2</span>:表达式<span class="hljs-number">3</span></code></pre><p>逻辑：表达式1必须是一个条件表达式，当表达式1的结果为true时，执行表达式2；反之，执行表达式3。</p></blockquote><h4 id="36-位运算了解"><a class="markdownIt-Anchor" href="#36-位运算了解"></a> 3.6 位运算(了解)</h4><blockquote><ol><li>将十进制的数转换成二进制的数，再根据 &amp;、|、^ 针对每一位进行逻辑运算，其中将 1 视为true， 0 视为false。</li><li>左移：a &lt;&lt; b ， 相当于 a * 2 的 b 次方</li></ol></blockquote><h3 id="四类型转换"><a class="markdownIt-Anchor" href="#四类型转换"></a> 四，类型转换</h3><blockquote><p>问：不同数据类型之间是否可以运算？</p><p>答：可以的，但是需要遵循自动类型转换的规则</p></blockquote><h4 id="41-自动类型转换"><a class="markdownIt-Anchor" href="#41-自动类型转换"></a> 4.1 自动类型转换</h4><blockquote><p>范围小的数据类型与范围大的数据类型运算，结果会自动转换成范围大的数据类型。</p><p>规则：</p><p>double &gt; float &gt; long &gt; int &gt; short &gt; byte</p></blockquote><blockquote><p>注：</p><ol><li><p>char 值 与 十进制数 可以根据 ASCII 码表进行转换</p><p>48 - 57 ：‘0’ - ‘9’</p><p>65 - 90 ：‘A’ - ‘Z’</p><p>97 - 122 : ‘a’ - ‘z’</p></li><li><pre class="highlight"><code class="java"><span class="hljs-keyword">byte</span> b1 = <span class="hljs-number">33</span>;<span class="hljs-comment">// 不会报错，33是一个常量</span><span class="hljs-keyword">int</span> i = <span class="hljs-number">33</span>;<span class="hljs-keyword">byte</span> b2 = i;<span class="hljs-comment">// 报错，i是一个int类型的变量</span>&lt;!--code￼<span class="hljs-number">8</span>--&gt;</code></pre></li></ol><p>注：</p><ol><li><p>byte、short、char 类型的变量在运算时，会自动转换成 int 类型</p></li><li><p>自增、自减中自带强制类型转换</p></li><li><p>+=、-= 等赋值运算符也自带强制类型转换</p></li><li><p>基本数据类型的强制类型转换慎用</p></li><li><p>int类型 和 char 类型 可以通过强制类型转换做交换，根据 unicode 码表</p><p>unicode 码表：称为 万国码 ，是一个前128位与ASCII码表完全相同，且收录了世界各国各地文字的码表</p></li></ol></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>面向对象基础</title>
    <link href="/2019/02/08/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/"/>
    <url>/2019/02/08/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h3 id="继承"><a class="markdownIt-Anchor" href="#继承"></a> 继承</h3><p>在 <code>Java</code>中继承使用 <code>extends</code>关键字,不像C++中存在多继承只存在单继承即子类只能有一个直接父类.</p><h4 id="继承的优点"><a class="markdownIt-Anchor" href="#继承的优点"></a> 继承的优点</h4><blockquote><p>继承可以降低代码冗余度,可以把多个类中共同的代码抽象出来,减少相同代码的重复编写</p></blockquote><p>在 <code>Java</code>中子类继承父类除 <code>构造方法</code>外的所有属性<br /><code>instanceof</code>关键字的使用规则 <code>对象 instanceof 类名</code>判断对象是否时某个类的对象, <code>Object</code>类是所有类的父类,因此在使用 <code>instanceof</code>判断的时候返回值都是 <code>true</code></p><p>父类Person类</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;睡觉&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;        <span class="hljs-keyword">this</span>.age = age;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> age;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;        <span class="hljs-keyword">this</span>.age = age;    &#125;&#125;</code></pre><p>Student子类继承Person类</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Student student = <span class="hljs-keyword">new</span> Student();        student.setId(<span class="hljs-number">1234</span>);        student.sleep();        System.out.println(student.id);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;    &#125;&#125;</code></pre><pre><code class="hljs 运行结果">睡觉1234true</code></pre><hr /><h3 id="封装"><a class="markdownIt-Anchor" href="#封装"></a> 封装</h3><h4 id="在封装中使用的关键字"><a class="markdownIt-Anchor" href="#在封装中使用的关键字"></a> 在封装中使用的关键字</h4><table><thead><tr><th style="text-align:center">修饰符</th><th style="text-align:center">同一个类</th><th style="text-align:center">同一个包</th><th style="text-align:center">子类</th><th style="text-align:center">其他包</th></tr></thead><tbody><tr><td style="text-align:center"><code>public</code></td><td style="text-align:center">可以访问</td><td style="text-align:center">可以访问</td><td style="text-align:center">可以访问</td><td style="text-align:center">可以访问</td></tr><tr><td style="text-align:center"><code>protected</code></td><td style="text-align:center">可以访问</td><td style="text-align:center">可以访问</td><td style="text-align:center">可以访问</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><code>default</code></td><td style="text-align:center">可以访问</td><td style="text-align:center">可以访问</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><code>private</code></td><td style="text-align:center">可以访问</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><p>一般在进行类的定义时使用 <code>private</code>关键字进行修饰,通过 <code>get set</code>方法对外界提供操作接口,从而达到封装的目的</p><hr /><h3 id="多态"><a class="markdownIt-Anchor" href="#多态"></a> 多态</h3><h4 id="父类引用指向子类对象是多态产生的经典概括指明了多态产生的条件"><a class="markdownIt-Anchor" href="#父类引用指向子类对象是多态产生的经典概括指明了多态产生的条件"></a> 父类引用指向子类对象是多态产生的经典概括,指明了多态产生的条件</h4><p>首先需要存在继承关系,在子类中重写父类中的方法,在创建对象时 <code>new</code>的是子类的构造函数,从而使得当调用子类重写父类的方法时,产生多态现象</p><hr /><h3 id="final关键字"><a class="markdownIt-Anchor" href="#final关键字"></a> <code>final</code>关键字</h3><p><code>final</code>修饰 <code>变量 方法 类</code>三种情况下的不同作用</p><ul><li>修饰 <code>变量</code>的时候,变量将会变成常量,该变量不能够被修改</li><li>如果实现了一个类不想要有子类继承可以使用<code>final</code>关键字修饰,那么子类就没法继承了.</li><li>如果在一个类中某一个方法不想要有被子类重写也可以使用<code>final</code>关键字进行修饰,但是该方法依然能够在本类中进行重载</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Java面向对象基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础</title>
    <link href="/2019/02/08/Java%E5%9F%BA%E7%A1%80/"/>
    <url>/2019/02/08/Java%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h3 id="一概述"><a class="markdownIt-Anchor" href="#一概述"></a> 一，概述</h3><h4 id="11-什么是程序-什么是程序开发"><a class="markdownIt-Anchor" href="#11-什么是程序-什么是程序开发"></a> 1.1 什么是程序、什么是程序开发</h4><blockquote><p>程序是为了解决生活中的实际问题使用计算机语言所编写的一系列的指令的集合。</p><p>程序开发：编写软件</p></blockquote><h4 id="12-java的历史"><a class="markdownIt-Anchor" href="#12-java的历史"></a> 1.2 Java的历史</h4><blockquote><p>1995年由SUN开发的面向对象的程序设计语言。</p><p>JDK1.5是2004年发布，Java被Oracle收购</p><p>​JavaME、JavaSE（标准版）、JavaEE（企业版）</p><p>JDK1.8是2014年发布</p></blockquote><h4 id="13-java语言的特点"><a class="markdownIt-Anchor" href="#13-java语言的特点"></a> 1.3 Java语言的特点</h4><blockquote><p>面向对象的编程思想</p><p>跨平台性：跨操作系统，一次编写、到处运行</p></blockquote><h3 id="二环境的搭建"><a class="markdownIt-Anchor" href="#二环境的搭建"></a> 二，环境的搭建</h3><blockquote><p>JDK：Java Development Kit，Java开发工具</p><p>JRE：Java Runtime Enviroment，Java运行环境</p><p>​JDK中包含JRE</p><p>JVM：Java Virtual Machine，Java虚拟机</p><p>​JRE中包含JVM</p></blockquote><blockquote><p>Java程序的开发流程和执行机制：</p><ol><li><p>编写代码，所编写的代码以 .java 为后缀</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;System.out.println(<span class="hljs-string">&quot;hello java&quot;</span>);&#125;&#125;</code></pre></li><li><p>对此 java 文件进行编译，使用 javac 指令，编译后会生成对应的 .class （二进制字节码）文件</p><pre><code class="hljs java">javac Test.java</code></pre></li><li><p>使用 java 指令运行程序</p><pre><code class="hljs cmake">java <span class="hljs-keyword">Test</span></code></pre><p>注：代码发生改变后，需要重新编译</p></li></ol></blockquote><blockquote><p>环境变量的配置：</p><p>问：为什么要配置环境变量？<br />答：因为 javac 指令在 安装 java 的 bin 目录下，Java 程序的运行需要 javac 这个指令。Java 程序的位置可能是任意的，我们需要在任何地方都可以使用 javac 这个指令</p><p>配置步骤：</p><ol><li>右键 “此电脑”，属性、高级系统设置、在“高级”标签页下点击“环境变量”</li><li>在“系统变量”中新建，在“变量名”中输入“JAVA_HOME”，在“变量值”中输入 jdk 的根路径</li><li>在“path”中添加 “%JAVA_HOME%\bin”、&quot;%JAVA_HOME%\jre\bin&quot;</li></ol></blockquote><h3 id="三第一个java程序"><a class="markdownIt-Anchor" href="#三第一个java程序"></a> 三，第一个Java程序</h3><blockquote><p>注意事项：</p><ol><li><p>代码的编码格式必须与 cmd 的编码格式统一</p></li><li><p>大括号必须成对出现</p></li><li><p>语句必须以 “;” 结尾</p></li><li><p>符号必须使用英文的</p></li><li><p>程序中必须有一个主函数，主函数必须被定义成</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span></code></pre></li><li><p>文件中的类名必须与文件名保持一致</p></li></ol></blockquote><h3 id="四基础语法"><a class="markdownIt-Anchor" href="#四基础语法"></a> 四，基础语法</h3><h4 id="41-缩进"><a class="markdownIt-Anchor" href="#41-缩进"></a> 4.1 缩进</h4><blockquote><p>每一行都要按下 tab 键，向后缩进</p></blockquote><h4 id="42-关键字"><a class="markdownIt-Anchor" href="#42-关键字"></a> 4.2 关键字</h4><blockquote><p>概念：Java 中系统已经预先定义好的具有特殊含义单词</p><p>例如：public、class、static、void、if、else、switch、case、for、do、while、abstract、implements、synchronized、this、super、return 等</p><p>注：main 不是关键字</p></blockquote><h4 id="43-标识符"><a class="markdownIt-Anchor" href="#43-标识符"></a> 4.3 标识符</h4><blockquote><p>概念：类名、方法名、<strong>变量名都是标识符</strong></p><p>规则：</p><ol><li>由数字、字母、下划线、美元符组成</li><li>不能以数字开头</li><li>不能与关键字重名</li></ol><p>规范：</p><ol><li>变量名/方法：首字母小写，多个单词组成时，从第二个单词起，每个单词的首字母大写（小驼峰）</li><li>类名：每个单词的首字母大写（大驼峰）</li><li>常量：所有字母全都大写，多个单词组成时，单词之间用下划线连接</li><li>见名知意</li><li>不宜过长</li></ol></blockquote><h4 id="44-注释"><a class="markdownIt-Anchor" href="#44-注释"></a> 4.4 注释</h4><blockquote><p>概念：对代码进行解释说明文字</p><p>特点：</p><p>​1.不参与程序的运行</p><ol start="2"><li>被注掉的代码不再运行</li></ol><p>格式：</p><ol><li>单行注释：// 注释内容</li><li>多行注释：/* 注释内容 */</li><li>文档注释：/** 注释内容 */</li></ol></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
